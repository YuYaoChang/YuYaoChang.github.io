<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache_Airflow_介紹及使用</title>
    <url>/2023/01/12/Apache_Airflow_%E4%BB%8B%E7%B4%B9%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>隨著工作上資料量、流程複雜度持續的增加，使用 Crontab 管理自動更新排程，已無法順利進行資料更新。<br>容易遇到前一個工作尚未進行完，下一個工作又要開始執行，且下一個工作需要使用上一個工作所產生的資料；<br>若繼續使用 Crontab 則會遇到資料量持續增加，而打亂自動更新排程，要常常調整排程時間設定來緩解這個情形，<br>因此，這次透過導入 Airflow 來解決此問題。</p>
<h2 id="Airflow-介紹"><a href="#Airflow-介紹" class="headerlink" title="Airflow 介紹"></a>Airflow 介紹</h2><p>Airflow 是一個工作流程管理系統(Workflow Management System)，將有相關的工作整合為一個有向無循環圖 DAG (Directed Acyclic Graph)，並提供多種 Operator，例如 Bash Operator、Python Operator 等，甚至可直接對 GCP、S3、Slack 等進行操作；DAG 是一個 Python 程式，可達到 Infrastructure as code，減少維運上的複雜度。<br><img src="/images/airflow/airflow_structure.png"></p>
<center><a  href="https://3lexw.medium.com/apache-airflow-2-1-%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8-2-%E5%AE%89%E8%A3%9D%E5%8F%8A%E5%9F%BA%E7%A4%8E%E8%A8%AD%E5%AE%9A-5622f7cff10d">圖片來源：3LexW</a></center>
<span id="more"></span>

<h3 id="Airflow-主要的元件"><a href="#Airflow-主要的元件" class="headerlink" title="Airflow 主要的元件"></a>Airflow 主要的元件</h3><ol>
<li>Airflow Webserver<br>提供圖形化介面，可快速看到排程執行的狀態、Log 或是手動執行等。</li>
<li>Airflow Scheduler<br>負責排程，從 Metadata Database 中找尋 DAG 跟 Task 的狀態，並判斷要將哪些 Task 傳送給 Executor 安排執行。</li>
<li>Airflow Executor<br>Executor 是一個 Queue Process，從 Scheduler 接收要執行的 Task，並將這些資訊存進 Queue，並從 Queue 中取出 Task 安排給閒置的 Worker 執行。</li>
<li>Airflow Worker<br>實際的排程工作就交由 Worker 來執行，同一個 Airflow cluster 中可以有多個 Worker，並且可透過指定 worker queue 使工作能在特定的資源上運作，而所有資料都被存在 Metadata Database 裡。</li>
<li>Metadata Database<br>儲存 DAG 執行的資訊、狀態 以及 Airflow 本身的設定如用戶、連線等設定。Web Server 顯示的資訊就是從 Metadata DB 來的，而 Scheduler 也會更新這些資訊到 DB 讓 Web 和 Scheduler 可以同步。</li>
</ol>
<h3 id="Airflow-優缺點"><a href="#Airflow-優缺點" class="headerlink" title="Airflow 優缺點"></a>Airflow 優缺點</h3><ul>
<li>優點</li>
</ul>
<ol>
<li>清晰易懂的管理介面</li>
<li>現成的 Operator 方便串接各式系統</li>
<li>較容易管理複雜的工作流程</li>
<li>Workflow as Code</li>
<li>各個工作失敗時自動重試</li>
<li>可設置失敗提醒(Email、Slack等)</li>
</ol>
<ul>
<li>缺點</li>
</ul>
<ol>
<li>多一套系統需維護</li>
<li>需設定一些相依服務（資料庫、RabbitMQ 之類的）</li>
<li>部署多組 Worker 時較麻煩</li>
<li>只能使用 pools 去限制同時有多少的 DAG 在運作，無法直接分配相應的 CPU 數量和 memory 大小</li>
</ol>
<hr>
<h2 id="Airflow-安裝"><a href="#Airflow-安裝" class="headerlink" title="Airflow 安裝"></a>Airflow 安裝</h2><h3 id="pip-安裝"><a href="#pip-安裝" class="headerlink" title="pip 安裝"></a>pip 安裝</h3><ol>
<li>Airflow 最簡單的安裝方法就是使用 pip 安裝<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安裝完整相關套件</span><br><span class="line">$pip3 install apache-airflow</span><br><span class="line"></span><br><span class="line"># 只要安裝部分相關套件(只安裝 celery, slack, redis)</span><br><span class="line">$pip3 install apache-airflow[celery,slack,redis]</span><br></pre></td></tr></table></figure></li>
<li>安裝後可執行初始化資料庫的指令，即可使用 sqlite 來儲存設定與 log 等<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow initdb</span><br></pre></td></tr></table></figure></li>
<li>可透過編輯預設路徑中 <code>$home/airflow/airflow.cfg</code> 的設定，改為使用 MySQL 等資料庫<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># airflow.cfg</span><br><span class="line">sql_alchemy_conn = mysql://DB_USERNAME:DB_PASSWORD@DB_HOST:DB_PORT/DB_database</span><br><span class="line"></span><br><span class="line"># 更改完再初始化一次資料庫</span><br><span class="line">$airflow initdb</span><br></pre></td></tr></table></figure></li>
<li>可用 command line 指令來啟動，也可以使用 systemd 等方式來管理<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow webserver</span><br><span class="line">$airflow scheduler</span><br><span class="line">$airflow worker</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用-docker-compose-安裝-推"><a href="#使用-docker-compose-安裝-推" class="headerlink" title="使用 docker compose 安裝 (推)"></a>使用 docker compose 安裝 (推)</h3><ol>
<li>建置 Airflow 環境</li>
</ol>
<ul>
<li>新建資料夾<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$mkdir airflow</span><br><span class="line">$cd airflow</span><br></pre></td></tr></table></figure></li>
<li>下載官方提供 docker-compose 文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以 Airflow 2.5.0 為例</span><br><span class="line">$curl -LfO &#x27;https://airflow.apache.org/docs/apache-airflow/2.5.0/docker-compose.yaml&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 docker-compose.yaml 設定環境變數<br>Airflow 提供了透過環境變數傳遞設定值的做法，格式上會像 <code>AIRFLOW__&lt;which part&gt;__&lt;which key&gt;</code><br>若設定 core 裡面的 sql_alchemy_conn，就會像是<code>export AIRFLOW__CORE__SQL_ALCHEMY_CONN=your database</code><br>調整時區則是在 environment 部分加入 <code>AIRFLOW__CORE__DEFAULT_TIMEZONE: &#39;Asia/Taipei&#39;</code></p>
</blockquote>
</li>
<li>產生相依目錄並設定 Airflow 使用者權限<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$mkdir -p ./dags ./logs ./plugins</span><br><span class="line">$echo -e &quot;AIRFLOW_UID=$(id -u)&quot; &gt; .env</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>資料庫初始化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker-compose up airflow-init</span><br></pre></td></tr></table></figure></li>
<li>啟動 Airflow 服務<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker-compose up -d</span><br><span class="line">$docker-compose ps # check it</span><br></pre></td></tr></table></figure></li>
<li>下載 airflow 命令工具<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$curl -LfO &#x27;https://airflow.apache.org/docs/apache-airflow/2.5.0/airflow.sh&#x27;</span><br><span class="line">$chmod +x airflow.sh</span><br></pre></td></tr></table></figure></li>
<li>撰寫 dags 程式<br>將 dags 程式放置於 Container 掛載目錄 dags，後面會再談到如何撰寫 dags 程式。</li>
<li>透過 airflow.sh 執行 DAG 程式<br>建立運行 python container <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$./airflow.sh bash</span><br></pre></td></tr></table></figure>
執行 python 檔案<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$python dags/file.py</span><br></pre></td></tr></table></figure></li>
<li>網頁中查看新建立的 DAG<br>Airflow Web Server<br><a href="http://localhost:8080/">http://localhost:8080</a></li>
<li>REST API<br>使用 <a href="https://airflow.apache.org/docs/apache-airflow/stable/stable-rest-api-ref.html">Airflow REST API</a> 可以取代在 WebUI 上的工作，進行 DAG 的抓取執行刪除等工作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$curl -X GET &#x27;http://&lt;主機&gt;:8080/api/v1/dags&#x27; --user &quot;airflow:airflow&quot;</span><br></pre></td></tr></table></figure>
回傳<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dag_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;fileloc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/opt/airflow/dags/file.py&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;is_active&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;is_paused&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;is_subdag&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;owners&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;root_dag_id&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;schedule_interval&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;__type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TimeDelta&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;days&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;microseconds&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;seconds&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="DAG-Directed-Acyclic-Graph"><a href="#DAG-Directed-Acyclic-Graph" class="headerlink" title="DAG (Directed Acyclic Graph)"></a>DAG (Directed Acyclic Graph)</h2><p>Airflow 只需使用最基本的 Bash Operator (其他的 Operator 後續將會介紹)，即可執行工作排程，而 Dag 建立的部分，除了直接拉變數出來建立，也可以透過以下兩種方式建立：</p>
<ol>
<li>透過 with 建立 Dag<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dag = DAG(dag_id=<span class="string">&quot;first_dag&quot;</span>, tags=[<span class="string">&#x27;user&#x27;</span>], start_date=datetime.today())</span><br><span class="line"><span class="keyword">with</span> dag:</span><br><span class="line">    start_task = EmptyOperator(task_id=<span class="string">&quot;start_task&quot;</span>)</span><br><span class="line">    end_task = EmptyOperator(task_id=<span class="string">&quot;end_task&quot;</span>)</span><br><span class="line">    first_task = BashOperator(task_id=<span class="string">&quot;first_task&quot;</span>,</span><br><span class="line">                              bash_command=<span class="string">f&quot;echo execute time: <span class="subst">&#123;datetime.now()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>透過 decorator 建立 Dag<br>需要於外部將該 Dag 的函式丟給一個變數，airflow 才可以抓到該 Dag<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow.decorators <span class="keyword">import</span> dag</span><br><span class="line"></span><br><span class="line"><span class="meta">@dag(<span class="params">tags=[<span class="string">&#x27;user&#x27;</span>], start_date=datetime.today(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_dag</span>():</span><br><span class="line">    start_task = EmptyOperator(task_id=<span class="string">&quot;start_task&quot;</span>)</span><br><span class="line">    end_task = EmptyOperator(task_id=<span class="string">&quot;end_task&quot;</span>)</span><br><span class="line">    first_task = BashOperator(task_id=<span class="string">&quot;first_task&quot;</span>,</span><br><span class="line">                              bash_command=<span class="string">f&quot;echo execute time: <span class="subst">&#123;datetime.now()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_dag = simple_dag()</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><a href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/models/dag/index.html">dag 參數</a>、<a href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/models/baseoperator/index.html">operator 參數</a></li>
</ul>
<p>完成 DAG 程式，可直接放入 airflow.cfg 指定的 DAG 資料夾，並且在介面上點選啟用即可</p>
<ul>
<li>範例<br>完整 DAG 程式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> DAG</span><br><span class="line"><span class="keyword">from</span> airflow.operators.bash_operator <span class="keyword">import</span> BashOperator</span><br><span class="line"></span><br><span class="line"><span class="comment"># default setting</span></span><br><span class="line">default_args = &#123;</span><br><span class="line">    <span class="string">&#x27;owner&#x27;</span>: <span class="string">&#x27;OWNER_NAME&#x27;</span>, <span class="comment"># dag 管理者名稱</span></span><br><span class="line">    <span class="string">&#x27;depends_on_past&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;start_date&#x27;</span>: airflow.utils.dates.days_ago(<span class="number">3</span>), <span class="comment"># 開始時間可使用相對時間，也可使用絕對時間</span></span><br><span class="line">    <span class="string">&#x27;email&#x27;</span>: [<span class="string">&#x27;OWNER_EMAIL&#x27;</span>], <span class="comment"># 要寄的 email</span></span><br><span class="line">    <span class="string">&#x27;email_on_failure&#x27;</span>: <span class="literal">False</span>, <span class="comment"># 失敗時寄 email</span></span><br><span class="line">    <span class="string">&#x27;email_on_retry&#x27;</span>: <span class="literal">False</span>, <span class="comment"># 重試時寄 email</span></span><br><span class="line">    <span class="string">&#x27;retries&#x27;</span>: <span class="number">1</span>, <span class="comment"># 執行失敗時，要重試多少次</span></span><br><span class="line">    <span class="string">&#x27;retry_delay&#x27;</span>: timedelta(minutes=<span class="number">5</span>), <span class="comment"># 執行失敗時，過多久才重試</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dag setting</span></span><br><span class="line">dag = DAG(</span><br><span class="line">    <span class="string">&#x27;example&#x27;</span>,</span><br><span class="line">    default_args=default_args,</span><br><span class="line">    description=<span class="string">&#x27;Example&#x27;</span>,</span><br><span class="line">    schedule_interval=<span class="string">&#x27;10 * * * *&#x27;</span>) <span class="comment"># 排程週期：直接按照 cron 的時間格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次的執行 DAG 的時間是 start_date + schedule_interval，但執行的 execution_date 將會是前一天</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define tasks</span></span><br><span class="line">start_task = EmptyOperator(task_id=<span class="string">&quot;start_task&quot;</span>)</span><br><span class="line"></span><br><span class="line">task1 = BashOperator(</span><br><span class="line">    task_id=<span class="string">&#x27;task_1&#x27;</span>,</span><br><span class="line">    bash_command=<span class="string">&#x27;/path/to/script/one.sh&#x27;</span>,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line">task2 = BashOperator(</span><br><span class="line">    task_id=<span class="string">&#x27;task_1&#x27;</span>,</span><br><span class="line">    bash_command=<span class="string">&#x27;/path/to/script/two.sh&#x27;</span>,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line">task3 = BashOperator(</span><br><span class="line">    task_id=<span class="string">&#x27;task_1&#x27;</span>,</span><br><span class="line">    bash_command=<span class="string">&#x27;/path/to/script/three.sh&#x27;</span>,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line">end_task = EmptyOperator(task_id=<span class="string">&quot;end_task&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_task &gt;&gt; task1 &gt;&gt; [task2,task3] &gt;&gt; end_task</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>‘start_date’ : datetime(2022, 1, 1, 0, 0)，執行時間將在 2022-01-02 做第一次執行<br>邏輯：在 2022-01-01 23:59 結束以後，也就是 2022-01-02 00:00 的時候，將 2022-01-01 所有的使用者資料做彙總</p>
</blockquote>
<h3 id="task-狀態"><a href="#task-狀態" class="headerlink" title="task 狀態"></a>task 狀態</h3><p><img src="https://i.imgur.com/gW6GGrd.png"><br>圖片來源：<a href="https://tw.coderbridge.com/series/c012cc1c8f9846359bb9b8940d4c10a8/posts/3d1f5ea33f5f4a3bac33f95099e376e8">FrankYang0529</a></p>
<ul>
<li>No status<br>當手動 Trigger DAG 或是 Scheduler 排程 DAG 後，DAG 的 Task 會先被創造成 Task Instance 並寫進 Database</li>
<li>Scheduled<br>當 Scheduler 確認某個 Task 需要被執行時，這時 Task 的狀態就會變成 Scheduled</li>
<li>Queued<br>當 Scheduler 把確定要執行的 Task 發送給 Executor 時，相當於把 Task 放入 Queue 裡</li>
<li>Running<br>Executor 將 Task 發送給閒置的 Worker</li>
<li>執行的結果<br>透過 Executor 將 Task 標示成 Success 或是 Failed</li>
</ul>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p><a href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/operators/index.html">Basic Operator</a></p>
<ul>
<li>Pools<br>資源控管用的變數，能夠限定執行的 operator 數量，在 UI 上新增一個 Pool<br>在 operator 設定 pool 參數<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">extract_product = MyPostgresOperator(</span><br><span class="line">    sql=<span class="string">&#x27;select_product.sql&#x27;</span></span><br><span class="line">    task_id=<span class="string">&#x27;extract_product&#x27;</span>,</span><br><span class="line">    pool=<span class="string">&#x27;pool_name&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="BranchPythonOperator"><a href="#BranchPythonOperator" class="headerlink" title="BranchPythonOperator"></a>BranchPythonOperator</h4><p>可以透過回傳的文字，決定下一個 Task 要執行什麼</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">branching = BranchPythonOperator(</span><br><span class="line">    task_id=<span class="string">&#x27;branching&#x27;</span>,</span><br><span class="line">    python_callable=<span class="keyword">lambda</span> **context: <span class="string">&#x27;store_in_redis&#x27;</span> <span class="keyword">if</span> <span class="built_in">int</span>(context[<span class="string">&#x27;task_instance&#x27;</span>].xcom_pull(task_ids=<span class="string">&#x27;get_timestamp&#x27;</span>)) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;skip&#x27;</span>,</span><br><span class="line">    provide_context=<span class="literal">True</span>,</span><br><span class="line">    dag=dag,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="自創-Operator"><a href="#自創-Operator" class="headerlink" title="自創 Operator"></a>自創 Operator</h4><p>Airflow 提供<a href="https://airflow.apache.org/docs/apache-airflow/stable/howto/custom-operator.html">自定義 Operator</a></p>
<p>Operator 路徑：預設在 <code>&#123;AIRFLOW_HOME&#125;/plugins</code></p>
<p>自定義的 Operator 會繼承 BaseOperator，只需要在 Constructor 中定義要傳入的參數，並實作 execute 函式就能完成 Operator 的基礎功能</p>
<h5 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h5><p>目標：讓 Operator 可以傳入使用者的名字，並且在執行時紀錄跟使用者打招呼的時間</p>
<p>在 Constructor 中，可使用 Airflow 定義好的裝飾器 <code>@apply_defaults</code>；透過 <code>@apply_defaults</code> 可幫 Operator 載入 Default Arguments，並存放在 kwargs[‘params’]，讓我們可以在 constructor 中調用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreetOperator</span>(<span class="title class_ inherited__">BaseOperator</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @apply_defaults</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            name: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">            *args, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>

<p>execute 函式帶有 context 變數，context 帶有一些功能，像是 ti 或 task_instance 代表 TaskInstance，透過 TaskInstance 可以跟 XCom 互動</p>
<ul>
<li>params<br>透過 params 可以傳遞自定義的參數進去 Task，在 Task 中，我們可以從 context.params 拿到這些參數<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dag = DAG(</span><br><span class="line">    ...,</span><br><span class="line">    params=&#123;</span><br><span class="line">        <span class="string">&quot;s3_bucket&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>Variables<br>在 WebServer 的 Admin → Variables 頁面看到，使用 key value 形式創造 Variable；可以是 json 的格式，因此可以用一個 Variable 就設定好一個 DAG 所需的全部參數，並在 DAG 裡面，透過 <code>Variable.get(&quot;some key&quot;)</code> 拿到 Variable。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dag = DAG(</span><br><span class="line">    ...,</span><br><span class="line">    params=Variable.get(<span class="string">&quot;test&quot;</span>, deserialize_json=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>Connections<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow.hooks.base_hook <span class="keyword">import</span> BaseHook</span><br><span class="line">redis_password = BaseHook.get_connection(<span class="string">&#x27;redis_default&#x27;</span>).password</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 Operator 中，執行結束回傳的值會被記錄在 XCom 的 return_value 裡，可以透過 TaskInstance 的 xcom_push 功能，存入其他的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, context</span>):</span><br><span class="line">    message = <span class="string">&quot;Hello &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">    context[<span class="string">&#x27;ti&#x27;</span>].xcom_push(key=<span class="string">&#x27;time&#x27;</span>, value=datetime.now().timestamp())</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="keyword">return</span> message</span><br></pre></td></tr></table></figure>

<p>定義 Airflow Plugin，讓我們待會再可以在 DAG 中引入我們的 Operator</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AirflowTestPlugin</span>(<span class="title class_ inherited__">AirflowPlugin</span>):</span><br><span class="line">    name = <span class="string">&#x27;greet_operator&#x27;</span></span><br><span class="line">    operators = [GreetOperator]</span><br></pre></td></tr></table></figure>

<p>完整 code</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> airflow.plugins_manager <span class="keyword">import</span> AirflowPlugin</span><br><span class="line"><span class="keyword">from</span> airflow.models.baseoperator <span class="keyword">import</span> BaseOperator</span><br><span class="line"><span class="keyword">from</span> airflow.utils.decorators <span class="keyword">import</span> apply_defaults</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreetOperator</span>(<span class="title class_ inherited__">BaseOperator</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @apply_defaults</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            name: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">            *args, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, context</span>):</span><br><span class="line">        message = <span class="string">&quot;Hello &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">        context[<span class="string">&#x27;ti&#x27;</span>].xcom_push(key=<span class="string">&#x27;time&#x27;</span>, value=datetime.now().timestamp())</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirflowTestPlugin</span>(<span class="title class_ inherited__">AirflowPlugin</span>):</span><br><span class="line">    name = <span class="string">&#x27;greet_operator&#x27;</span></span><br><span class="line">    operators = [GreetOperator]</span><br></pre></td></tr></table></figure>

<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Airflow Executor <a href="https://docs.astronomer.io/learn/airflow-executors-explained">(不同 Executor 比較)</a></p>
<ul>
<li>Local Executor：單機版的 Executor，可透過 MultiProcess 同時運行多個 Worker</li>
<li>Celery Executor：使用 Celery 分散式的 Task Queue 當作 Executor，所以可以在多台電腦同時運行多個 Worker<br><img src="https://i.imgur.com/RtTHUB4.png"></li>
<li>Kubernetes Executor：透過 Kubernetes API 為每個工作開啟一個 Pod，工作完成後就會砍掉，可以跟據每個工作分配不同的 CPU、memory、設定等，達到資源利用最大化<br><img src="https://i.imgur.com/AB1V8pg.png"><br><img src="https://i.imgur.com/Cznu44B.png"></li>
</ul>
<p><em><strong>這部分目前筆者著墨不多，後續有碰到再寫篇文章說明</strong></em></p>
<h3 id="XCOM"><a href="#XCOM" class="headerlink" title="XCOM"></a>XCOM</h3><p>task_1 會將執行結果存到database，task_2 再從database來取得其執行結果，這便是 Xcom 的使用方式(以PythonOperator為例):</p>
<ol>
<li>設定operator的參數 <code>provide_context=True</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_operator = PythonOperator(</span><br><span class="line">    task_id=<span class="string">&#x27;my_task&#x27;</span>,</span><br><span class="line">    python_callable=func,</span><br><span class="line">    provide_context=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>使用方式</li>
</ol>
<ul>
<li>在 function 使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**context</span>):</span><br><span class="line">    ti = context[<span class="string">&#x27;task_instance&#x27;</span>]</span><br><span class="line">    previous_result = ti.xcom_pull(task_ids=<span class="string">&#x27;previous_work&#x27;</span>) <span class="comment"># 得到上游的執行結果(key的default值為&#x27;return_value&#x27;)</span></span><br><span class="line">    new_result = previous_result + <span class="number">100</span> <span class="comment"># 得到的新結果</span></span><br><span class="line">    ti.xcom_push(key=<span class="string">&#x27;xcom_push&#x27;</span>, value=new_result) <span class="comment"># 存入Xcom(key=&#x27;xcom_push&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> new_result <span class="comment"># return 也會存到Xcom(key=&#x27;return_value&#x27;)</span></span><br></pre></td></tr></table></figure></li>
<li>使用其他 Operator<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2 = BashOperator(</span><br><span class="line">    task_id=<span class="string">&#x27;t2&#x27;</span>, </span><br><span class="line">    bash_command=<span class="string">&#x27;echo &quot;&#123;&#123; ti.xcom_pull(&quot;t1&quot;) &#125;&#125;&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>XCom 的所有資料在 pickle 之後會被存到 Airflow 的 Metadata Database，因此不適合交換太大的數據</p>
</blockquote>
<h3 id="重複利用-Python-function"><a href="#重複利用-Python-function" class="headerlink" title="重複利用 Python function"></a>重複利用 Python function</h3><p>利用一個 Python 函式 process_metadata 專門負責讀 &#x2F; 寫使用者的閱讀紀錄，兩個 Airflow 工作的 python_callable 都呼叫 process_metadata，利用不同的 op_args 來使用 process_metadata 函式的不同功能：</p>
<ul>
<li>get_read_history 負責讀取閱讀紀錄</li>
<li>update_read_history 負責更新閱讀紀錄</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_metadata</span>(<span class="params">mode, **context</span>):</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;read&#x27;</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;write&#x27;</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> DAG(<span class="string">&#x27;comic_app_v3&#x27;</span>, default_args=default_args) <span class="keyword">as</span> dag:</span><br><span class="line"></span><br><span class="line">    get_read_history = PythonOperator(</span><br><span class="line">        task_id=<span class="string">&#x27;get_read_history&#x27;</span>,</span><br><span class="line">        python_callable=process_metadata,</span><br><span class="line">        op_args=[<span class="string">&#x27;read&#x27;</span>],</span><br><span class="line">        provide_context=<span class="literal">True</span></span><br><span class="line">		)       </span><br><span class="line"></span><br><span class="line">    update_read_history = PythonOperator(</span><br><span class="line">        task_id=<span class="string">&#x27;update_read_history&#x27;</span>,</span><br><span class="line">        python_callable=process_metadata,</span><br><span class="line">        op_args=[<span class="string">&#x27;write&#x27;</span>],</span><br><span class="line">        provide_context=<span class="literal">True</span></span><br><span class="line">		)</span><br></pre></td></tr></table></figure>

<h3 id="Trigger-Rules"><a href="#Trigger-Rules" class="headerlink" title="Trigger Rules"></a>Trigger Rules</h3><p>可以透過前面 Tasks 的狀態，來判斷後面的 Tasks 要不要執行，讓 Scheduler 判斷要不要將某個 Task 放入排程</p>
<ul>
<li>all_success<br>某個 Task 的上游 Tasks 的狀態都要是成功，才會執行這個 Task</li>
<li>all_failed<br>上游 Tasks 的狀態都是失敗時執行，這可以用於處理 exception 狀態</li>
<li>all_done<br>只要上游 Tasks 完成，不管它們的狀態是成功、失敗或是 skipped，都會執行</li>
<li>one_failed<br>上游 Tasks 其中一個失敗就執行，這個 Trigger Rule 不會等上游 Tasks 都完成才執行，而是只要有失敗就立即執行</li>
<li>one_success<br>上游 Tasks 其中一個成功就立即執行</li>
<li>none_failed<br>上游 Tasks 的狀態都是成功或是 skipped</li>
<li>none_skipped<br>上游 Tasks 的狀態是成功或是失敗時執行</li>
</ul>
<hr>
<h2 id="Airflow-cfg"><a href="#Airflow-cfg" class="headerlink" title="Airflow.cfg"></a>Airflow.cfg</h2><p>使用 docker-compose 建立 airflow 的話，可以跳過這篇，<br>docker-compose 是透過”環境變數傳遞設定值”的方法設定，即 <code>AIRFLOW__&lt;...&gt;__&lt;...&gt;: True</code></p>
<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>Airflow 設定參數的核心，會記錄 Metadata Database、DAG 資料夾位置、Plugins 資料夾位置等</p>
<ul>
<li>dags_folder<br>存放 DAG 的資料夾，在 local 一般會是 <code>~/airflow/dags</code> 對應的絕對路徑</li>
<li>plugins_folder<br>存放 Operator 的資料夾，在 local 一般會是 <code>~/airflow/plugins</code> 對應的絕對路徑</li>
<li>sql_alchemy_conn<br>Database 的連線位置，預設用 SQLite 連到 <code>~/airflow/airflow.db</code> 的位置；SQLite 一般只用於開發，到了線上環境將換成其他 Database</li>
<li>Remote Logging<ul>
<li>remote_logging<br>是否開啟遠端紀錄 Log，目前支援 AWS S3、Google Cloud Storage、Elastic Search</li>
<li>remote_log_conn_id<br>若要開啟，要記得先到 Connections 頁面創建一個 conn_id<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Conn Id: s3_conn</span><br><span class="line">Conn Type: S3</span><br><span class="line">Extra: &#123;&quot;aws_access_key_id&quot;:&quot;your_aws_key_id&quot;, &quot;aws_secret_access_key&quot;: &quot;your_aws_secret_key&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>remote_base_log_folder<br>與 base_log_folder 類似，也就是在遠端 log 要存放的相對位置</li>
</ul>
</li>
<li>executor<br>預設的 Executor 是 SequentialExecutor，也可換成 LocalExecutor、CeleryExecutor、KubernetesExecutor等</li>
<li>load_examples<br>在線上環境，如果不想看到 Airflow 預設的 Example DAG，可以透過這個參數關掉<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_examples = False</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p>透過 cli 跟線上環境溝通</p>
<ul>
<li>api_client</li>
</ul>
<ol>
<li>airflow.api.client.local_client<br>Airflow 會直接跟設定檔裡設定的 Database 溝通</li>
<li>airflow.api.client.json_client<br>Airflow 會跟 endpoint_url 所設定的 WebServer 溝通</li>
</ol>
<ul>
<li>endpoint_url<br>Airflow WebServer 的 url</li>
</ul>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>只有一個設定值 fail_fast<br>若要啟用，要將 executor 改成 DebugExecutor，這個設定值會讓 DAG 裡面只要有一個 Task 狀態是 failed，整個 DAG 的狀態也會變成 failed</p>
<h3 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h3><ul>
<li>base_url<br>跟 email 比較有關係，Default Args 裡面的 email_on_failure 可以在 Task 失敗時自動寄信，Airflow 信中的內容會包括 WebServer 的位置，而這個位置就是 base_url</li>
<li>SSL<br>可以透過 <code>web_server_ssl_cert</code> 及 <code>web_server_ssl_key</code> 設定 SSL 憑證</li>
<li>secret_key<br>在線上環境，也要記得指定 <code>secret_key</code>，因為 Airflow 的 WebServer 是使用 Flask 實現的，Flask 會透過 <code>secret_key</code> 來對 cookies 簽名</li>
</ul>
<h3 id="smtp"><a href="#smtp" class="headerlink" title="smtp"></a>smtp</h3><p>設定 Airflow 寄信的相關設定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[smtp]</span><br><span class="line">smtp_host = smtp.gmail.com</span><br><span class="line">smtp_starttls = True</span><br><span class="line">smtp_ssl = False</span><br><span class="line">smtp_user = YOUR_EMAIL_ADDRESS</span><br><span class="line">smtp_password = 16_DIGIT_APP_PASSWORD</span><br><span class="line">smtp_port = 587</span><br><span class="line">smtp_mail_from = YOUR_EMAIL_ADDRESS</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/70681089/gcp-command-to-retrieve-an-smtp-password-for-airflow">GCP SMTP 設定</a></p>
<hr>
<h2 id="Command-Line-Interface-CLI"><a href="#Command-Line-Interface-CLI" class="headerlink" title="Command Line Interface (CLI)"></a>Command Line Interface (CLI)</h2><p>若不需要使用 GUI 介面，也可直接使用 CLI，附上 command</p>
<h3 id="Dags"><a href="#Dags" class="headerlink" title="Dags"></a>Dags</h3><h4 id="查詢-dags-列表"><a href="#查詢-dags-列表" class="headerlink" title="查詢 dags 列表"></a>查詢 dags 列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow dags list</span><br></pre></td></tr></table></figure>
<h4 id="執行一次測試-dags"><a href="#執行一次測試-dags" class="headerlink" title="執行一次測試 dags"></a>執行一次測試 dags</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow dags test &lt;DAG_ID&gt; &lt;EXECUTION_TIME&gt;</span><br></pre></td></tr></table></figure>
<h4 id="刪除-dags"><a href="#刪除-dags" class="headerlink" title="刪除 dags"></a>刪除 dags</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow dags delete &lt;DAG_ID&gt;</span><br></pre></td></tr></table></figure>
<h4 id="顯示-dags-結構"><a href="#顯示-dags-結構" class="headerlink" title="顯示 dags 結構"></a>顯示 dags 結構</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow dags show &lt;DAG_ID&gt;</span><br><span class="line"># save</span><br><span class="line">$airflow dags show &lt;DAG_ID&gt; --save &lt;FILE_NAME.png&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><h4 id="初始化資料庫"><a href="#初始化資料庫" class="headerlink" title="初始化資料庫"></a>初始化資料庫</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow db init</span><br></pre></td></tr></table></figure>
<h4 id="查詢資料庫狀態"><a href="#查詢資料庫狀態" class="headerlink" title="查詢資料庫狀態"></a>查詢資料庫狀態</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow db check</span><br></pre></td></tr></table></figure>
<h4 id="更新資料庫"><a href="#更新資料庫" class="headerlink" title="更新資料庫"></a>更新資料庫</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow db upgrade</span><br></pre></td></tr></table></figure>
<h4 id="訪問資料庫"><a href="#訪問資料庫" class="headerlink" title="訪問資料庫"></a>訪問資料庫</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow db shell</span><br></pre></td></tr></table></figure>
<h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><h4 id="查詢-dags-中的-tasks"><a href="#查詢-dags-中的-tasks" class="headerlink" title="查詢 dags 中的 tasks"></a>查詢 dags 中的 tasks</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow tasks list &lt;DAG_ID&gt;</span><br></pre></td></tr></table></figure>
<h4 id="執行-dags-中的其中一個-task"><a href="#執行-dags-中的其中一個-task" class="headerlink" title="執行 dags 中的其中一個 task"></a>執行 dags 中的其中一個 task</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow tasks test &lt;DAG_ID&gt; &lt;TASK_ID&gt; &lt;EXECUTION_TIME&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h3><h4 id="查詢-users"><a href="#查詢-users" class="headerlink" title="查詢 users"></a>查詢 users</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow users list</span><br></pre></td></tr></table></figure>
<h4 id="創建-user"><a href="#創建-user" class="headerlink" title="創建 user"></a>創建 user</h4><ul>
<li>For Airflow &gt;&#x3D;2.0.0:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow users  create --role &lt;user_role&gt; --username &lt;username&gt; --email &lt;email&gt; --firstname &lt;firstname&gt; --lastname &lt;lastname&gt; --password &lt;password&gt;</span><br><span class="line"># role includes admin, user, op, viewer, public</span><br></pre></td></tr></table></figure></li>
<li>For Airflow &lt;1.10.14:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow create_user -r &lt;user_role&gt; -u &lt;username&gt; -e &lt;email&gt; -f &lt;firstname&gt; -l &lt;lastname&gt; -p &lt;password&gt;</span><br><span class="line"># role includes admin, user, op, viewer, public</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="刪除-user"><a href="#刪除-user" class="headerlink" title="刪除 user"></a>刪除 user</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$airflow users delete -u &lt;USERNAME&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Airflow-的擴充性"><a href="#Airflow-的擴充性" class="headerlink" title="Airflow 的擴充性"></a>Airflow 的擴充性</h2><ol>
<li>Airflow 有提供 Operators 就使用 Airflow</li>
<li>如果沒有提供那就透過繼承使用 Hooks 連接外部服務自制 Operators</li>
<li>Hooks 沒辦法解決的話則視問題的分類<ul>
<li>資料處理或統計可以匯入資料到 SQL&#x2F;BigQuery 解決</li>
<li>執行指令可以製作 Docker image 透過 DockerOperator&#x2F;KubernetesPodOperator 執行</li>
</ul>
</li>
</ol>
<hr>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="http://apache-airflow-docs.s3-website.eu-central-1.amazonaws.com/index.html">Airflow Documentation</a></li>
<li><a href="https://stackoverflow.com/questions/66160780/first-time-login-to-apache-airflow-asks-for-username-and-password-what-is-the-u">Create username and password Apache Airflow</a></li>
<li><a href="https://stackoverflow.com/questions/43410836/how-to-remove-default-example-dags-in-airflow">How to remove default example dags in airflow</a></li>
<li><a href="https://dev.to/hyperredstart/airflow-chu-ti-yan-4a6a">使用 docker-compose 建立 airflow</a></li>
<li><a href="https://leemeng.tw/a-story-about-airflow-and-data-engineering-using-how-to-use-python-to-catch-up-with-latest-comics-as-an-example.html">資料工程以及 Airflow</a></li>
<li><a href="https://tw.coderbridge.com/series/c012cc1c8f9846359bb9b8940d4c10a8">Airflow 動手玩</a></li>
<li><a href="https://3lexw.medium.com/apache-airflow-2-1-%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8-2-%E5%AE%89%E8%A3%9D%E5%8F%8A%E5%9F%BA%E7%A4%8E%E8%A8%AD%E5%AE%9A-5622f7cff10d">Airflow 安裝及基礎設定</a></li>
</ul>
<p><br /><br />作者：Ian Chang <br />網址： <a href="https://yuyaochang.github.io/2023/01/12/Apache_Airflow_%E4%BB%8B%E7%B4%B9%E5%8F%8A%E4%BD%BF%E7%94%A8/">https://yuyaochang.github.io/2023/01/12/Apache_Airflow_介紹及使用&#x2F;</a> <br />版權聲明：Blog中所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/tw/">CC BY-NC-SA 3.0 TW</a> 許可協議，若要轉載請註明出處</p>
]]></content>
      <categories>
        <category>Airflow</category>
      </categories>
      <tags>
        <tag>Airflow</tag>
        <tag>Python</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>從0到1</title>
    <url>/2022/08/21/Blog%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>終於架好這個網站了！！<br>架完之後第一件事情就是想著第一篇文章要寫什麼 XD</p>
<p>本來想直接寫架這個網站的過程，<br>但感覺好像會太枯燥 XD</p>
<p>只好先來聊聊為什麼會開始寫Blog ~</p>
<span id="more"></span>
<h3 id="為什麼會開始寫Blog？"><a href="#為什麼會開始寫Blog？" class="headerlink" title="為什麼會開始寫Blog？"></a>為什麼會開始寫Blog？</h3><p>我本身不是資工、資管背景出身的，<br>過去所學的R、Python等程式語言都是透過自學而來，<br>在自學、解決問題的道路上，<br>總是透過Google瀏覽各大網站，<br>拜訪許多前輩的Blog、Stack Overflow等等。</p>
<p>在過程中，我感受到知識、經驗分享的重要性，<br>雖然就目前而言，比起許多前輩自己還很菜 XD，<br>但希望能夠從現在開始透過寫Blog慢慢將所學到的知識、經驗記錄下來，<br>並且回饋給有需要的人。</p>
<h3 id="Blog的目的？"><a href="#Blog的目的？" class="headerlink" title="Blog的目的？"></a>Blog的目的？</h3><p>在這個網站中，不會只寫跟程式有關的內容，<br><del>只寫程式有關也太無聊</del><br>基本上我希望能夠把我學過的任何東西記錄下來，<br>因此，目前網站規劃三大類：</p>
<ol>
<li><p>程式相關<br>建立學習歷程，記錄、分享所學到的知識、經驗等</p>
</li>
<li><p>金融相關<br>程式交易策略、金融相關知識等</p>
</li>
<li><p>生活瑣事<br>讀書心得、想到什麼寫什麼，純粹記錄(?)</p>
</li>
</ol>
<p>當然也希望前輩們可以給我一些指教 XD<br>coding review的概念(?)</p>
<h3 id="自我期許"><a href="#自我期許" class="headerlink" title="自我期許"></a>自我期許</h3><p>當然除了不斷更新這個Blog外，<br>就是要不斷精進自己，<br>保持自己的好奇心，<br>學習各方面知識。</p>
<p>堅持一直以來放在我心中的二句話：</p>
<blockquote>
<p>成為海盜學者，學海無涯，為盜是岸  - James Marcus Bach<br>Stay Hungry, Stay Foolish. - Steve Jobs</p>
</blockquote>
<p>最後，希望一年後的自己，看到現在寫的code會想笑 XD</p>
<p><br /><br />作者：Ian Chang <br />網址： <a href="https://yuyaochang.github.io/2022/08/21/Blog%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">https://yuyaochang.github.io/2022/08/21/Blog的第一篇文章/</a> <br />版權聲明：Blog中所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/tw/">CC BY-NC-SA 3.0 TW</a> 許可協議，若要轉載請註明出處</p>
]]></content>
      <categories>
        <category>生活瑣事</category>
      </categories>
      <tags>
        <tag>生活瑣事</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主題設定、實際使用Hexo及Hexo其他常用套件</title>
    <url>/2022/09/18/NexT%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A%E3%80%81%E5%AF%A6%E9%9A%9B%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AHexo%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%A5%97%E4%BB%B6/</url>
    <content><![CDATA[<p>上一篇介紹有關<a href="https://yuyaochang.github.io/2022/09/04/%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8EHexo%E8%88%87Github%E6%9E%B6%E8%A8%ADBlog%E7%B6%B2%E7%AB%99/#more"><strong>如何透過Hexo與Github架設Blog網站</strong></a>，<br>這一篇來介紹<strong>NexT主題設定、實際使用Hexo及Hexo其他常用套件</strong></p>
<h2 id="Theme-NexT"><a href="#Theme-NexT" class="headerlink" title="Theme:NexT"></a>Theme:NexT</h2><p>主題的部分，<a href="https://hexo.io/themes/">Hexo官網</a>上有許多主題可供大家下載，<br>建議可以找近期還有在維護的主題，<br>本篇以許多人選擇的<a href="https://github.com/theme-next/hexo-theme-next">NexT主題</a>為例。<br>(因為我喜歡乾淨整潔的畫面私心推薦XD)<span id="more"></span></p>
<h3 id="NexT基本安裝"><a href="#NexT基本安裝" class="headerlink" title="NexT基本安裝"></a>NexT基本安裝</h3><p>雖然說叫安裝，但其實也只是把它從Github上面拉下來，<br>首先，先切換到<code>themes/</code>資料夾中，並建立一個<code>NexT</code>資料夾，<br>完成後，再開啟Terminal到Repository的資料夾中，<br>並從<a href="https://github.com/theme-next/hexo-theme-next">NexT Github</a>中將所有檔案<code>$git clone</code>下來。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$cd</span> <span class="string">&lt;repo_file&gt;</span> <span class="comment"># 通常為 &lt;user_name&gt;.github.io</span></span><br><span class="line"><span class="string">$git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/hexo-theme-next</span> <span class="string">themes/NexT</span></span><br></pre></td></tr></table></figure>
<p>clone完成後，必須修改根目錄的<code>_config.yml</code>檔案，<br>將<code># Extensions</code>中的<code>theme:</code>部分加入資料夾名稱<code>NexT</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">&lt;Blog主題&gt;</span> <span class="comment"># NexT</span></span><br></pre></td></tr></table></figure>
<p>修改完根目錄的<code>_config.yml</code>並Deploy就完成NexT基本安裝了。</p>
<h3 id="NexT-config-yml-設定"><a href="#NexT-config-yml-設定" class="headerlink" title="NexT _config.yml 設定"></a>NexT _config.yml 設定</h3><p>由於NexT可以加入的功能太多種，以下將挑幾個較容易使用到的來做說明：</p>
<h4 id="NexT設置Blog的logo"><a href="#NexT設置Blog的logo" class="headerlink" title="NexT設置Blog的logo"></a>NexT設置Blog的logo</h4><p>如果希望更改Blog網站的logo，<br>只要將圖片放入<code>NexT/source/images/</code>資料夾中，<br>並調整以下code(使用不同裝置開啟所顯示的圖片)，<br>即可變更Blog的logo。<br>(建議將要更換的logo圖片大小，調整成與預設NexT圖片大小一致)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<h4 id="NexT版型設定"><a href="#NexT版型設定" class="headerlink" title="NexT版型設定"></a>NexT版型設定</h4><p>NexT目前有四種版型，<br>想更換版型的話可在<code>Schemes</code>這邊進行調整(都是黑白為主)，<br>剛安裝完成預設主題將會是Muse，拿掉註解即可更換，<br>可以利用<code>$hexo server</code>自己trytry看想要使用哪一種。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<h4 id="NexT-menu"><a href="#NexT-menu" class="headerlink" title="NexT menu"></a>NexT menu</h4><p>這部分主要是在調整網站其他頁面的icon，<br>如：首頁(home)、關於我(about)、標籤(tags)、分類(categories)等，<br>(這裡調整後，要記得到根目錄的<code>_config.yml</code>檔案，將<code># Header</code>的部分對應的頁面註解拿掉，才會顯示出頁面)<br><code>||</code>後面是指想要使用的icon，<br>icon將使用<a href="https://fontawesome.com/icons?d=gallery">Font Awesome</a>(fa)網站中的icon，<br>基本上大部分只需要輸入<code>fa fa-&lt;icon_name&gt;</code>即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="網站訪問人數、文章閱讀人數"><a href="#網站訪問人數、文章閱讀人數" class="headerlink" title="網站訪問人數、文章閱讀人數"></a>網站訪問人數、文章閱讀人數</h4><p>如果想在網站底下新增累積Blog訪問人數、累積文章閱讀人數，<br>只要將<code>enable: false</code>改為<code>enable: true</code>即可開啟該功能，<br>同時，也可以透過Font Awesome來改變icon。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h4 id="Google-Analytics-GA"><a href="#Google-Analytics-GA" class="headerlink" title="Google Analytics(GA)"></a>Google Analytics(GA)</h4><p>首先要先擁有一個Google帳號，並前往<a href="https://analytics.google.com/analytics/web/provision/#/provision">Google Analytics</a>開啟服務，<br>開啟GA服務後，要先建立一個GA的帳戶，<br>建立完成後，到<code>設定 &gt; 帳戶 &gt; 資料流串 &gt; 網頁串流詳情(GA_id)</code>，<br><img src="/images/hexo_github/GA_id.jpg" width="50%"><br>找到GA_id後，將這串GA_id複製貼到以下<code>tracking_id</code>這邊做設定即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span> <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line">  <span class="comment"># By default, NexT will load an external gtag.js script on your site.</span></span><br><span class="line">  <span class="comment"># If you only need the pageview feature, set the following option to true to get a better performance.</span></span><br><span class="line">  <span class="attr">only_pageview:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="社群網站連結設定"><a href="#社群網站連結設定" class="headerlink" title="社群網站連結設定"></a>社群網站連結設定</h4><p>將社群網站連結加入Blog中，<br>(可以透過Font Awesome來改變icon)<br>只要將連結的註解取消即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || fab fa-github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:your@mail.com || fa fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure>
<h4 id="側邊大頭貼設定"><a href="#側邊大頭貼設定" class="headerlink" title="側邊大頭貼設定"></a>側邊大頭貼設定</h4><p>若要開啟此功能，只要將下方<code>url</code>部分的註解拿掉即可，<br>目前預設圖像是<code>avatar.gif</code>(一個灰色人像)，<br>想要跟換的話，只要將大頭貼放到<code>next/source/images/&lt;your_photo&gt;</code>並更改<code>url</code>就可以更換完成了。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>以上就是NexT主題大部分常用的設定，其他可以再自行研究看裡面的內容 ~</p>
<h3 id="Theme-NexT-Canvas-Nest"><a href="#Theme-NexT-Canvas-Nest" class="headerlink" title="Theme NexT Canvas Nest"></a>Theme NexT Canvas Nest</h3><p><a href="https://github.com/theme-next/theme-next-canvas-nest">Theme NexT Canvas Nest</a>是一個很有科技感<del>炫炮</del>的背景(本站使用之背景)，<br>要如何設定這個<del>炫炮的</del>背景，<br>首先，先到根目錄<code>source/</code>中創一個<code>_data/</code>資料夾，<br>並在<code>_data/</code>資料夾中，創一個<code>footer.swig</code>檔案，<br><code>footer.swig</code>檔案中寫入並儲存以下code：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script color=&quot;0,0,255&quot; opacity=&quot;0.5&quot; zIndex=&quot;-1&quot; count=&quot;300&quot; src=&quot;https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>寫完儲存後，<br>只要到根目錄<code>_config.yml</code>檔案中將<code>footer</code>註解拿掉即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig # 側邊欄</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig # 文章標題下</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig # 文章結尾</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<h2 id="實際使用Hexo"><a href="#實際使用Hexo" class="headerlink" title="實際使用Hexo"></a>實際使用Hexo</h2><p>Blog基本上就是拿來寫文章用的，<br>在寫文章的過程中，<br>一定會有將文章分類的需求(還是只有我有強迫症XDD)，<br>因此，建立一個分類選項、標籤是非常重要的。</p>
<h3 id="創建分類選項、標籤"><a href="#創建分類選項、標籤" class="headerlink" title="創建分類選項、標籤"></a>創建分類選項、標籤</h3><p>在Hexo中想要將文章分類，需要先創建一個分類選項，<br>透過下面指令，創建一個分類頁面：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">categories</span></span><br></pre></td></tr></table></figure>
<p>創建後，<code>source/categories/</code>資料夾中會有一個檔案<code>index.md</code>，<br>內容預設是像這樣：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment"># 創建的時間</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>之後將type加入到內容中並儲存</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment"># 創建的時間</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p><strong>使用：</strong>只要在文章前面加入categories就可以將文章分類</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment"># 文章主題</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment"># 發文時間</span></span><br><span class="line"><span class="attr">categories:</span> <span class="comment"># 分類</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>同樣的，如果要創造標簽的話，<br>只需要照前面的步驟創建tags即可。<br><strong>這裡要注意的是：</strong><br>一篇文章只能有一種分類，<br>如果在這加入多個分類，<br>將會默認選擇第一個分類。</p>
<h2 id="Hexo其他常用套件"><a href="#Hexo其他常用套件" class="headerlink" title="Hexo其他常用套件"></a>Hexo其他常用套件</h2><h3 id="hexo-addlink"><a href="#hexo-addlink" class="headerlink" title="hexo-addlink"></a>hexo-addlink</h3><p><strong>功能：</strong>在每篇文章最後添加永久鏈接及文字(像簽名檔、版權聲明的概念)。<br><strong>安裝、使用：</strong>安裝<code>hexo-addlink</code>套件後，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$npm</span> <span class="string">install</span> <span class="string">hexo-addlink</span></span><br></pre></td></tr></table></figure>
<p>將下面的code加在根目錄<code>_config.yml</code>檔案中。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">addlink:</span></span><br><span class="line">  <span class="attr">before_text:</span> <span class="comment"># 加在網址前面的文字</span></span><br><span class="line">  <span class="attr">after_text:</span> <span class="comment"># 加在網址後面的文字</span></span><br></pre></td></tr></table></figure>
<h3 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h3><p><strong>功能：</strong>Google是透過sitemap來取得網站資料，但Hexo並無內建必須額外安裝套件，才能讓你的Blog被搜尋到。<br><strong>安裝、使用：</strong>安裝<code>hexo-generator-sitemap</code>套件後，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$npm</span> <span class="string">install</span> <span class="string">hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure>
<p>在根目錄的<code>_config.yml</code>中加入以下code即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span> <span class="comment"># sitemap path</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="literal">false</span> <span class="comment"># include true, exclude false</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">false</span> <span class="comment"># include true, exclude false</span></span><br></pre></td></tr></table></figure>
<p>完成後，以後在產生靜態網頁時，將會自動產生出<code>sitemap.xml</code>檔案，<a href="https://awoo.ai/zh-hant/blog/sitemap-xml/#%E5%88%B0%E5%BA%95%EF%BC%8Csitemapxml%E6%98%AF%E4%BB%80%E9%BA%BC%E6%9D%B1%E8%A5%BF%EF%BC%81%EF%BC%9F">進一步了解sitemap.xml是什麼</a><br>(可以在<code>https://&lt;user_name&gt;.github.io/sitemap.xml</code>查看<code>sitemap.xml</code>是否產生成功)<br>以上步驟完成後，<br>要到<a href="https://search.google.com/search-console/about">Google Search Console</a>輸入Blog網址以及<code>sitemap.xml</code>，如下：<br><img src="/images/hexo_github/sitemap.jpg" width="100%"><br>看到狀態成功，即完成sitemap設定，<br>之後Google就會定期看這個檔案是否有更新，<br>如果有更新將會把新的網址(新文章的分頁)加入Google搜尋引擎中。<br>後續如果有<strong>文章不想加入搜尋引擎中</strong>，也可以在標題部分加入：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">sitemap:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>這樣那篇文章就不會加入Google搜尋引擎中。</p>
<h3 id="hexo-generator-searchdb"><a href="#hexo-generator-searchdb" class="headerlink" title="hexo-generator-searchdb"></a>hexo-generator-searchdb</h3><p><strong>功能：</strong>在Blog中使用關鍵字搜索文章<br><strong>安裝、使用：</strong>安裝<code>hexo-generator-searchdb</code>套件後，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$npm</span> <span class="string">install</span> <span class="string">hexo-generator-searchdb</span></span><br></pre></td></tr></table></figure>
<p>到<code>themes/source/next/_config.yml</code>檔案，<br>找到以下這段code，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>改成<code>enable: true</code>即可。</p>
<p>當然還有很多<a href="https://hexo.io/plugins/">hexo套件</a>可以使用，可以依照個人需求去找找~</p>
<p>延伸閱讀：<br><a href="https://yuyaochang.github.io/2022/09/04/%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8EHexo%E8%88%87Github%E6%9E%B6%E8%A8%ADBlog%E7%B6%B2%E7%AB%99/#more">如何透過Hexo與Github架設Blog網站</a></p>
<p><br /><br />作者：Ian Chang <br />網址： <a href="https://yuyaochang.github.io/2022/09/18/NexT%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A%E3%80%81%E5%AF%A6%E9%9A%9B%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AHexo%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%A5%97%E4%BB%B6/">https://yuyaochang.github.io/2022/09/18/NexT主題設定、實際使用Hexo及Hexo其他常用套件/</a> <br />版權聲明：Blog中所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/tw/">CC BY-NC-SA 3.0 TW</a> 許可協議，若要轉載請註明出處</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Recommendation_System_推薦系統概念介紹_Python</title>
    <url>/2022/11/03/Recommendation_System_%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%B4%B9_Python/</url>
    <content><![CDATA[<p>推薦系統就像是一種 “訊息過濾系統”，<strong>會依照特定的規則進行過濾，並預測用戶對商品的評分或偏好</strong>，<br>透過推薦系統能夠降低消費者的選擇時間，提高衝動購買的機率，幫助用戶找到最適合自己、最感興趣的商品。</p>
<p>推薦系統的演算法發展至今，Python、R 等許多程式都有提供相關套件進行推薦系統的演算法運算，<br>因此就目前而言，不是著重於如何實現這些演算法運算，而是透過哪個演算法才能夠解決當下的問題。</p>
<p><img src="/images/recommender_system/recommender_system_classfiy.jpg"><span id="more"></span></p>
<hr>
<h2 id="非客製化推薦-Non-Personalized"><a href="#非客製化推薦-Non-Personalized" class="headerlink" title="非客製化推薦 ( Non-Personalized )"></a>非客製化推薦 ( Non-Personalized )</h2><p>在企業、商業模式草創初期，銷售的商品品項不多，又或只專注於銷售單一商品造成銷售量差異懸殊時，<br>無須使用客製化推薦，以非客製化推薦效益較高。</p>
<h3 id="Item-Based"><a href="#Item-Based" class="headerlink" title="Item-Based"></a>Item-Based</h3><h4 id="熱銷商品推薦"><a href="#熱銷商品推薦" class="headerlink" title="熱銷商品推薦"></a>熱銷商品推薦</h4><p>透過所有用戶對於商品的熱度或點閱率等方式來進行商品推薦 ( 對於時效性議題、商品非常有效 )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">ratings = &#123;</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[*(<span class="string">&#x27;item_A &#x27;</span>*<span class="number">100</span>).split(),*(<span class="string">&#x27;item_B &#x27;</span>*<span class="number">30</span>).split(),*(<span class="string">&#x27;item_C &#x27;</span>*<span class="number">40</span>).split(),*(<span class="string">&#x27;item_D &#x27;</span>*<span class="number">130</span>).split()],</span><br><span class="line">    <span class="string">&#x27;rating&#x27;</span>:<span class="built_in">list</span>(np.random.randint(<span class="number">1</span>,<span class="number">5</span>,size = <span class="number">300</span>))</span><br><span class="line">&#125;</span><br><span class="line">ratings = pd.DataFrame(ratings)</span><br><span class="line"><span class="comment"># ratings 用戶評分資料，商品與評分兩個欄位</span></span><br><span class="line">frequency = ratings[<span class="string">&#x27;item&#x27;</span>].value_counts()</span><br><span class="line"><span class="comment"># 篩選 item 筆數大於 50 筆的資料</span></span><br><span class="line">item_frequency = frequency[frequency &gt; <span class="number">50</span>].index</span><br><span class="line"><span class="comment"># 將資料筆數較少的資料刪除</span></span><br><span class="line">item_frequent = ratings[ratings[<span class="string">&#x27;item&#x27;</span>].isin(item_frequency)]</span><br><span class="line"><span class="comment"># 計算每一個 item 的平均分數</span></span><br><span class="line">avg_rating = item_frequent[[<span class="string">&#x27;item&#x27;</span>,<span class="string">&#x27;rating&#x27;</span>]].groupby([<span class="string">&#x27;item&#x27;</span>]).mean()</span><br><span class="line"><span class="comment"># 根據分數進行排序</span></span><br><span class="line">sort_item_rating = avg_rating.sort_values(by=<span class="string">&#x27;rating&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 列出想要優先推薦的 item 順序</span></span><br><span class="line">sort_item_rating</span><br></pre></td></tr></table></figure>

<h4 id="隨機推薦"><a href="#隨機推薦" class="headerlink" title="隨機推薦"></a>隨機推薦</h4><p>隨機投遞商品或物品給用戶 ( 隨機的結果可能比運算的結果還要好 )</p>
<h3 id="User-Based"><a href="#User-Based" class="headerlink" title="User-Based"></a>User-Based</h3><h4 id="用戶推薦-x2F-建議"><a href="#用戶推薦-x2F-建議" class="headerlink" title="用戶推薦&#x2F;建議"></a>用戶推薦&#x2F;建議</h4><p>計算觀看相似商品的用戶，可能會對哪些商品有興趣；可將此應用至草創初期，<br>即當用戶隨意點一項商品後，直接推薦相似的商品給其他用戶。</p>
<ul>
<li>透過窮盡法將所有可能列舉出來(排列組合)，不考慮不同評分間的差異，取出推薦組合次數最多的商品。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations <span class="comment"># 使用 Permutation tool 進行取後不放回的抽樣(列出所有可能的排列組合)</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">user_item = &#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>:[<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">user_item = pd.DataFrame(user_item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_pairs</span>(<span class="params">item_df</span>):</span><br><span class="line">    pairs = <span class="built_in">list</span>(permutations(item_df.values,<span class="number">2</span>)) <span class="comment"># 從item隨機抽取2個取後不放回</span></span><br><span class="line">    pairs = pd.DataFrame(pairs,columns=[<span class="string">&#x27;item_1&#x27;</span>,<span class="string">&#x27;item_2&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> pairs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將資料進行轉換</span></span><br><span class="line">item_pairs = user_item.groupby(<span class="string">&#x27;user&#x27;</span>)[<span class="string">&#x27;item&#x27;</span>].apply(create_pairs).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 計算 item_1 對應到 item_2 的個別總數</span></span><br><span class="line">pair_counts = item_pairs.groupby([<span class="string">&#x27;item_1&#x27;</span>,<span class="string">&#x27;item_2&#x27;</span>]).size()</span><br><span class="line"><span class="comment"># 從大到小進行排序</span></span><br><span class="line">pair_counts = pair_counts.to_frame(name=<span class="string">&#x27;counts&#x27;</span>).reset_index().sort_values(<span class="string">&#x27;counts&#x27;</span>,ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 篩選出其中的 item_A，就會列出想要優先推薦的 item 順序</span></span><br><span class="line">pair_counts</span><br></pre></td></tr></table></figure>

<h2 id="客製化推薦-Personalized"><a href="#客製化推薦-Personalized" class="headerlink" title="客製化推薦 ( Personalized )"></a>客製化推薦 ( Personalized )</h2><h3 id="Item-Based-1"><a href="#Item-Based-1" class="headerlink" title="Item-Based"></a>Item-Based</h3><h4 id="內容過濾-Content-Based-Filtering"><a href="#內容過濾-Content-Based-Filtering" class="headerlink" title="內容過濾 ( Content-Based Filtering )"></a>內容過濾 ( Content-Based Filtering )</h4><p>針對商品內容進行分析，找出商品間的關聯性並進行分類 ( 利用商品屬性 Matrix，進行相似度分析 )，<br>可解決冷啟動問題 ( 解釋性、效果較佳 )，並且可針對用戶過去喜歡的商品，推薦類似品項給用戶。</p>
<img src="/images/recommender_system/contentbased_filtering.jpg" width="50%">

<h5 id="特徵相似度-Feature-Similarity"><a href="#特徵相似度-Feature-Similarity" class="headerlink" title="特徵相似度 ( Feature Similarity )"></a>特徵相似度 ( Feature Similarity )</h5><p>適合用於推薦新用戶，當新用戶進入頁面時，可藉由一些判斷標準 ( 點選的商品、購買目的、用途等 )，<br>了解新用戶的興趣並進行推薦，不需等新用戶導覽完全部商品後再進行推薦。</p>
<ul>
<li>Jaccard Similarity ( Jaccard 相似度 )<br>所有聯集中，有多少比例是交集，判斷哪些商品出現的機率較高，但無不同商品間評分的差異。</li>
</ul>
<img src="/images/recommender_system/jaccard_similarity.jpg" width="20%">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_score <span class="comment"># 使用 sklearn 的 matrics 來計算 jaccard 相似度</span></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">user_item = &#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>:[<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemD&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">user_item = pd.DataFrame(user_item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 資料轉換成 dummy variable / one-hot encode</span></span><br><span class="line">user_item_crosstab = pd.crosstab(user_item[<span class="string">&#x27;item&#x27;</span>],user_item[<span class="string">&#x27;user&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 篩選資料類別</span></span><br><span class="line">item_A_crosstab = user_item_crosstab[user_item_crosstab.index == <span class="string">&#x27;itemA&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------計算單一 jaccard 相似度------------- #</span></span><br><span class="line"><span class="comment"># 個別取出各自欄位的資料</span></span><br><span class="line">item_A_row = user_item_crosstab.loc[<span class="string">&#x27;itemA&#x27;</span>]</span><br><span class="line">item_B_row = user_item_crosstab.loc[<span class="string">&#x27;itemB&#x27;</span>]</span><br><span class="line">jaccard_score(item_A_row,item_B_row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------計算整張表格商品的相似度係數------------- #</span></span><br><span class="line"><span class="comment"># 計算所有商品間的 jaccard distance</span></span><br><span class="line">jaccard_distances = pdist(user_item_crosstab.values,metric=<span class="string">&#x27;jaccard&#x27;</span>)</span><br><span class="line"><span class="comment"># 將原本 Cn 取 2 的 array 轉換成 n * n 的矩陣</span></span><br><span class="line"><span class="comment"># 原先距離最遠會計算出 1，因此相似度就要以 1 - 原先值</span></span><br><span class="line">jaccard_sim_array = <span class="number">1</span> - squareform(jaccard_distances)</span><br><span class="line">jaccard_sim_df = pd.DataFrame(jaccard_sim_array,index=user_item_crosstab.index,columns=user_item_crosstab.index)</span><br><span class="line"><span class="comment"># 搜尋特定商品，並找出該商品與其他商品的相似度</span></span><br><span class="line">jaccard_sim_series = jaccard_sim_df.loc[<span class="string">&#x27;itemA&#x27;</span>]</span><br><span class="line">ordered_jaccard_sim = jaccard_sim_series.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="文本相似度-Text-Based-Similarity"><a href="#文本相似度-Text-Based-Similarity" class="headerlink" title="文本相似度 ( Text-Based Similarity )"></a>文本相似度 ( Text-Based Similarity )</h5><p>以商品 text 為主，利用協同過濾 ( Item-based ) 對無特定 Feature 進行計算</p>
<ul>
<li>很多商品無法被分類或參照，僅有一些文字可作為參考，因此可藉由 NLP ( Nature Language Processing ) 領域的 TF-IDF ( Terms Frequency — Inverse Document Frequency ) 演算法，求出每篇文章或每個商品文案中，每個字詞的重要程度。</li>
</ul>
<img src="/images/recommender_system/tf_idf.jpg" width="50%">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer <span class="comment"># TF-IDF 套件</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">item_desc = &#123;</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>,<span class="string">&#x27;itemD&#x27;</span>,<span class="string">&#x27;itemE&#x27;</span>,<span class="string">&#x27;itemF&#x27;</span>,<span class="string">&#x27;itemG&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;desc&#x27;</span>:[<span class="string">&#x27;Inspected and guaranteed to have minimal cosmetic damage, which is not noticeable when the device is held at arms length. Successfully passed a full diagnostic test which ensures like-new functionality and removal of any prior-user personal information.&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Includes a brand new, generic charging cable that is certified Mfi (Made for iPhone) and a brand new, generic wall plug that is UL certified for performance and safety. Also includes a SIM tray removal tool but does not come with headphones or a SIM card.&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Tested for battery health and guaranteed to come with a battery that exceeds 90% of original capacity&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;This product is in &quot;Good condition&quot;. The screen has no scratches; body shows light scratches barely visible from 12 inches away.&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Product will come with a SIM removal tool, a charger and a charging cable. Headphone and SIM card are not included.&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;This product is eligible for a replacement or refund within 90-day of receipt if it does not work as expected.&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Successfully passed a full diagnostic test which ensures like-new functionality and removal of any prior-user personal information.&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最少出現在3篇以上才不算是停止詞（Stop words），若超過50%文件都有這個詞亦會被當作停止詞</span></span><br><span class="line">vectorizer = TfidfVectorizer(min_df=<span class="number">3</span>,max_df=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 詞頻轉換</span></span><br><span class="line">vectorized_data = vectorizer.fit_transform(item_desc[<span class="string">&#x27;desc&#x27;</span>]) <span class="comment"># 壓縮過後的稀疏矩陣（Sparse Matrix）</span></span><br><span class="line"><span class="comment"># vectorizer.get_feature_names() # 轉換後的詞類向量</span></span><br><span class="line"><span class="comment"># 將原本的稀疏矩陣轉換成array再轉換成DataFrame，並以原先的詞類向量來設定欄位名稱</span></span><br><span class="line">tfidf_df = pd.DataFrame(vectorized_data.toarray(),columns=vectorizer.get_feature_names())</span><br><span class="line">tfidf_df.index = item_desc[<span class="string">&#x27;item&#x27;</span>]</span><br><span class="line"><span class="comment"># 計算好所有的詞頻後，透過演算法餘弦相似度（Cosine Similarity）來進行計算</span></span><br><span class="line"><span class="comment"># 接續下一個 cell </span></span><br></pre></td></tr></table></figure>

<ul>
<li>Cosine Similarity 餘弦相似度<br>兩個向量之間的餘弦值，能夠透過歐基理得點積公式求出<img src="/images/recommender_system/cosine_1.jpg" width="20%">
將兩邊同除兩向量的純量乘積後得出(類似標準化過程)
<img src="/images/recommender_system/cosine_2.jpg" width="50%">
Cosine Similarity
<img src="/images/recommender_system/cosine.jpg" width="20%"></li>
</ul>
<p>餘弦值會介於 -1 ~ 1 之間，若兩個向量方向接近則會越接近 1 ，反方向則為 -1，而 0 代表兩者間是獨立的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cosine_similarity_array = cosine_similarity(tfidf_df)</span><br><span class="line"><span class="comment"># 將資料轉換為 DF 型態以方便進行資料檢視與處理</span></span><br><span class="line">cosine_similarity_df = pd.DataFrame(cosine_similarity_array,index=tfidf_df.index,columns=tfidf_df.index)</span><br><span class="line"><span class="comment"># 搜尋出我們想要尋找的商品</span></span><br><span class="line">cosine_similarity_series = cosine_similarity_df.loc[<span class="string">&#x27;itemA&#x27;</span>]</span><br><span class="line"><span class="comment"># 將商品資料從高到低排序好</span></span><br><span class="line">ordered_similarities = cosine_similarity_series.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 了解與 item_A 商品，最接近的商品推薦排序，並進行推薦</span></span><br><span class="line">ordered_similarities</span><br></pre></td></tr></table></figure>

<h3 id="Item-x2F-User-Based"><a href="#Item-x2F-User-Based" class="headerlink" title="Item &#x2F; User-Based"></a>Item &#x2F; User-Based</h3><h4 id="協同過濾-Collaborative-Filtering"><a href="#協同過濾-Collaborative-Filtering" class="headerlink" title="協同過濾 ( Collaborative Filtering )"></a>協同過濾 ( Collaborative Filtering )</h4><p>演算法的計算資料，是來自於用戶對於特定商品的評分或購買項目</p>
<img src="/images/recommender_system/collaborative_filtering.jpg" width="70%">

<ul>
<li><p>Memory-Based</p>
<ul>
<li><p>Item-Based<br>「買了什麼東西，還會買什麼東西」，這樣的情境其中一種解決方案就是使用協同過濾，透過用戶瀏覽過的商品決定如何進行推薦，如：喜歡A商品也喜歡B&#x2F;C&#x2F;D商品的用戶有多少，透過計算商品間的相似程度，並將相似的商品推薦給用戶。</p>
<ol>
<li>發掘用戶潛在興趣</li>
<li>推薦結果容易變化，缺乏穩定性</li>
<li>冷啟動問題 ( Cold Start )，初期推薦效果非常差</li>
<li>資料稀疏問題，需要以 KNN／MF 矩陣分解來解決</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 透過前面的 TF-IDF Matrix (tfidf_df) 來選出用戶有選過的 item 並以加權平均把用戶的 Feature 計算出來，再計算 Cosine Similarity</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line">user_item = &#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>:[<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">user_item = pd.DataFrame(user_item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 篩選出用戶曾經買過的商品，每個商品總共被用戶買過幾次</span></span><br><span class="line">list_of_items = pd.DataFrame(user_item.groupby([<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;item&#x27;</span>])[<span class="string">&#x27;item&#x27;</span>].count())</span><br><span class="line">list_of_items.columns = [<span class="string">&#x27;counts&#x27;</span>]</span><br><span class="line"><span class="comment"># 取一位用戶</span></span><br><span class="line">userA = list_of_items.loc[<span class="string">&#x27;userA&#x27;</span>].reset_index()</span><br><span class="line"><span class="comment"># 以 userA 計算加權 TF-IDF score</span></span><br><span class="line">tfidf_user_enjoyed = tfidf_df.reindex(userA.item.tolist())</span><br><span class="line"><span class="comment"># 計算 user 的 TF-IDF score</span></span><br><span class="line">tfidf_user_prob = tfidf_user_enjoyed.mean()</span><br><span class="line"><span class="comment"># 將用戶已瀏覽過的商品剔除 TF-IDF 矩陣外，以剩下的商品來計算餘弦相似度</span></span><br><span class="line">non_user_items = tfidf_df.drop(list_of_items.loc[<span class="string">&#x27;userA&#x27;</span>].index,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># sklearn 預設只能讀取二維 array，使用 reshape 來轉換成僅有一列，而 -1 則是讓 numpy 自行計算總共要幾列(讓矩陣自動變成二維 array)</span></span><br><span class="line">cosine_similarity_userA = cosine_similarity(tfidf_user_prob.values.reshape(<span class="number">1</span>,-<span class="number">1</span>),non_user_items)</span><br><span class="line">user_prof_similarities_df = pd.DataFrame(cosine_similarity_userA.T,index=non_user_items.index,columns=[<span class="string">&#x27;similarity_score&#x27;</span>])</span><br><span class="line">sorted_similarity_df = user_prof_similarities_df.sort_values(by=<span class="string">&#x27;similarity_score&#x27;</span>,ascending=<span class="literal">False</span>)</span><br><span class="line">sorted_similarity_df</span><br></pre></td></tr></table></figure>
</li>
<li><p>User-Based<br>「用於不同的商品間，用戶與用戶之間的相似度」，針對用戶興趣進行分析，找出相同類型的群體行為來進行決策，計算用戶間的相似程度 (ex: Cosine-Similarity )，並將用戶有興趣的商品(TopN)推薦給相似用戶；同時，需先蒐集用戶資訊，如：評價、購買記錄等</p>
<ul>
<li>對於所有的商品評分都減掉各自的平均，就會變成皮爾森相關係數 （ Pearson Correlation Coefficient ），比 Cosine Similarity 多減掉平均<img src="/images/recommender_system/pearson_correlation_coefficient.jpg" width="30%"></li>
</ul>
<ol>
<li>隨著資料累積時間增加，推薦系統會越來越穩定，且能在商品上架前計算演算法矩陣</li>
<li>無法推薦用戶潛在感興趣的商品、特徵難以抽取，有冷啟動問題（Cold Start），沒有用戶資料便無法推薦</li>
<li>資料稀疏問題，需要以 KNN／MF 矩陣分解來解決</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">user_item_rating = &#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>:[<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>,<span class="string">&#x27;userD&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>,<span class="string">&#x27;userD&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>,<span class="string">&#x27;itemD&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;rating&#x27;</span>:[<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">user_item_rating = pd.DataFrame(user_item_rating)</span><br><span class="line"></span><br><span class="line">user_ratings_pivot = user_item_rating.pivot(index=<span class="string">&#x27;user&#x27;</span>,columns=<span class="string">&#x27;item&#x27;</span>,values=<span class="string">&#x27;rating&#x27;</span>)</span><br><span class="line"><span class="comment"># 計算平均以中心化各項商品的評分，並將各用戶的數據減掉各自商品的平均</span></span><br><span class="line">avg_ratings = user_ratings_pivot.mean(axis=<span class="number">1</span>)</span><br><span class="line">user_ratings_pivot = user_ratings_pivot.sub(avg_ratings,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 將沒有值的地方先簡單補上 0</span></span><br><span class="line">user_ratings_pivot_filled = user_ratings_pivot.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 將矩陣轉置為計算 User 間的相似度，並傳入 DataFrame</span></span><br><span class="line">similarities = cosine_similarity(user_ratings_pivot_filled.T)</span><br><span class="line">user_ratings_cos = pd.DataFrame(similarities,index=user_ratings_pivot_filled.index,columns=user_ratings_pivot_filled.index)</span><br><span class="line"><span class="comment"># user_ratings_cos.apply(lambda x: round(x, 2))</span></span><br><span class="line"><span class="comment"># 獲得與 user_A 相似的用戶</span></span><br><span class="line">ordered_similarities_userA = user_ratings_cos.loc[<span class="string">&#x27;userA&#x27;</span>].sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">ordered_similarities_userA</span><br></pre></td></tr></table></figure>

<p>計算出 User-based 的 Cosine Similarity 矩陣後，會有許多地方出現遺漏值 ( Missing Value )，原因在於不是每個用戶都會對各個商品評分或按讚，因此需透過補值的方式來填補遺漏值，如： KNN 插值等。</p>
<ul>
<li>KNN (K-Nearest Neighbors)<br>以周圍指定的 K 個數中，佔比最多的那個類別就歸類為該類別，避免指定偶數項；當數字完全相同時，KNN 可能就會選不出來（如果以 Cosine 則可能比較難重複），或是會隨機從中挑一個出來。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">user_item_rating = &#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>:[<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>,<span class="string">&#x27;userD&#x27;</span>,<span class="string">&#x27;userE&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;itemA&#x27;</span>:[<span class="number">5</span>,np.nan,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">    <span class="string">&#x27;itemB&#x27;</span>:[<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;itemC&#x27;</span>:[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line">user_item_rating = pd.DataFrame(user_item_rating).set_index(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">user_item_rating_df = user_item_rating.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將商品評分資料中，想要預測的商品資料欄位刪除</span></span><br><span class="line">user_item_rating.drop(<span class="string">&#x27;itemA&#x27;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 將我們想要預測的用戶資料翠取出來，之後 KNN 就會根據現有的這些欄位，來預測用戶其他沒有評分的分數</span></span><br><span class="line">target_user_x = user_item_rating.loc[[<span class="string">&#x27;userA&#x27;</span>]]</span><br><span class="line"><span class="comment"># 將尚未填補、含有 NaN 缺值的資料放到要用於訓練的 y</span></span><br><span class="line">other_users_y = user_item_rating_df[<span class="string">&#x27;itemA&#x27;</span>]</span><br><span class="line"><span class="comment"># 藉由前面有 NaN 的列，篩選出沒有 Nan 的資料行</span></span><br><span class="line">other_users_x = user_item_rating[other_users_y.notnull()]</span><br><span class="line"><span class="comment"># 將有 Nan 的去掉</span></span><br><span class="line">other_users_y.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 初始化 KNN 模型，並以 cosine 相似度來計算（記得這裡的資料都還沒有計算與弦相似度）</span></span><br><span class="line">user_knn = KNeighborsRegressor(metric=<span class="string">&#x27;cosine&#x27;</span>,n_neighbors=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 訓練與預測 KNN 模型</span></span><br><span class="line">user_knn.fit(other_users_x,other_users_y)</span><br><span class="line">user_user_pred = user_knn.predict(target_user_x)</span><br><span class="line"><span class="comment"># 明確有預測結果的欄位，來預測特定 User 對特定欄位的評分值（這裡是 item_A）</span></span><br><span class="line"><span class="comment"># KNN Regression 則是將周圍的 10 個資料點用於計算平均後輸出</span></span><br><span class="line"><span class="comment"># 這個插值法一樣也能倒過來使用，亦即用原先用 User 的評價來補齊其他評價；這次則可以用其他商品來當作訓練集，來預測特定商品的分數</span></span><br><span class="line">user_user_pred</span><br></pre></td></tr></table></figure>

<ul>
<li>Matrix Factorization<br>透過 KNN 填補用戶沒有填寫的評分，僅能用在商品品項不多的情況下；若商品品項較多、使用過該商品的比例非常低， KNN 所預測出來的值將會不準確，因此需使用矩陣分解（Matrix Factorization）來解決資料稀疏的問題，即透過 MF 可以將原本的矩陣拆解為兩個矩陣相乘 ( 用更少的資料來代表原本的矩陣 )，並抽取出特徵矩陣 ( User 特徵 + Item 特徵 )，其中 User 特徵又稱為潛藏特徵（Latent Factors）。<img src="/images/recommender_system/MF.jpg" width="80%">
MF 分解雖然會造成資訊損失（Information Loss），但可以解決運算量、資料稀疏造成協同過濾演算法難以計算的困境，而如何使用 MF 拆開兩個矩陣，最常被應用的方法是奇異值分解（Singular Value Decomposition）。
<img src="/images/recommender_system/MF_SVD.jpg" width="70%">
SVD 為一種降維工具，可拆解成 U, Sigma, Vt 三個矩陣，而對角矩陣可以針對 U 和 Vt 進行線性變換，而 Sigma 則作為這兩個矩陣的中介，並且 Sigma 被稱為奇異值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> svd</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">user_item_rating = &#123;</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>:[<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>,<span class="string">&#x27;userD&#x27;</span>,<span class="string">&#x27;userA&#x27;</span>,<span class="string">&#x27;userB&#x27;</span>,<span class="string">&#x27;userC&#x27;</span>,<span class="string">&#x27;userD&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>,<span class="string">&#x27;itemD&#x27;</span>,<span class="string">&#x27;itemB&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemA&#x27;</span>,<span class="string">&#x27;itemC&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;rating&#x27;</span>:[<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">user_item_rating = pd.DataFrame(user_item_rating)</span><br><span class="line"></span><br><span class="line">user_ratings_pivot = user_item_rating.pivot(index=<span class="string">&#x27;user&#x27;</span>,columns=<span class="string">&#x27;item&#x27;</span>,values=<span class="string">&#x27;rating&#x27;</span>)</span><br><span class="line"><span class="comment"># 計算平均以中心化各項商品的評分，並將各用戶的數據減掉各自商品的平均</span></span><br><span class="line">avg_ratings = user_ratings_pivot.mean(axis=<span class="number">1</span>)</span><br><span class="line">user_ratings_pivot = user_ratings_pivot.sub(avg_ratings,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 將沒有值的地方先簡單補上 0</span></span><br><span class="line">user_ratings_pivot_filled = user_ratings_pivot.fillna(<span class="number">0</span>).to_numpy()</span><br><span class="line"><span class="comment"># 計算 SVD 的三個矩陣</span></span><br><span class="line">U, sigma, Vt = svd(user_ratings_pivot_filled)</span><br><span class="line"><span class="comment"># 恢復原先的矩陣，將計算出的矩陣去中心化</span></span><br><span class="line">U_sigma_Vt = np.dot(np.dot(U,sigma),Vt)</span><br><span class="line">uncentered_ratings = U_sigma_Vt + avg_ratings.values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">calc_pred_ratings_df = pd.DataFrame(uncentered_ratings,index=user_ratings_pivot.index,columns=user_ratings_pivot.columns)</span><br><span class="line"><span class="comment"># 以 SVD 進行預測推薦</span></span><br><span class="line">userA_ratings = calc_pred_ratings_df.loc[<span class="string">&#x27;userA&#x27;</span>,:].sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">userA_ratings</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 檢驗 SVD 的表現程度</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 透過遮罩來藏起左上角的 3*3 的值</span></span><br><span class="line">actual_values = user_ratings_pivot.fillna(<span class="number">0</span>).iloc[:<span class="number">3</span>,:<span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 以平均來預測左上角的 3*3 的值</span></span><br><span class="line">col_mean = np.nanmean(user_ratings_pivot.to_numpy(),axis=<span class="number">0</span>)</span><br><span class="line">inds = np.where(np.isnan(user_ratings_pivot.to_numpy()))</span><br><span class="line">user_ratings_pivot.to_numpy()[inds] = np.take(col_mean,inds[<span class="number">1</span>])</span><br><span class="line">avg_values = user_ratings_pivot.iloc[:<span class="number">3</span>,:<span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 將上面 SVD 計算出來的矩陣取出遮罩 3*3 的範圍</span></span><br><span class="line">predicted_values = calc_pred_ratings_df.iloc[:<span class="number">3</span>,:<span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過遮罩產生 Non-Nan 的真值矩陣</span></span><br><span class="line">mask = ~np.isnan(actual_values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較單純透過平均和使用 SVD 的預測結果</span></span><br><span class="line"><span class="built_in">print</span>(mean_squared_error(actual_values[mask],avg_values[mask],squared=<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(mean_squared_error(actual_values[mask],predicted_values[mask],squared=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Model-Based<br>透過用戶歷史紀錄訓練出模型進行預測，如：LSTM 預測時間序列，當今天看完第一集會想接續看第二、第三集等。</p>
</li>
</ul>
<h5 id="如何選擇協同過濾要使用-User-Based-還是-Item-Based-呢？"><a href="#如何選擇協同過濾要使用-User-Based-還是-Item-Based-呢？" class="headerlink" title="如何選擇協同過濾要使用 User-Based 還是 Item-Based 呢？"></a>如何選擇協同過濾要使用 User-Based 還是 Item-Based 呢？</h5><p>  User-Based：通常推薦最熱門(點擊率最高)的商品，但該商品不一定是用戶最有興趣的。<br>  Item-Based：容易推薦長尾 (long-tail) 的商品(購買聲量不高，但會持續購買的商品)。</p>
<ul>
<li>Case1：電商擁有許多用戶資料(既有客戶、潛在客戶、沉睡客戶等)，若使用 User-Based 計算用戶相似度，將會耗費大量的時間，因此會使用 Item-Based 的協同過濾系統。</li>
<li>Case2：部落格是以提供內容為主的網站，在推薦文章給讀者時，由於文章會一直更新，較適合使用 User-Based 的協同過濾系統。</li>
</ul>
<h4 id="混合推薦-Hybrid-Approach"><a href="#混合推薦-Hybrid-Approach" class="headerlink" title="混合推薦(Hybrid Approach)"></a>混合推薦(Hybrid Approach)</h4><ul>
<li>不同商品適合不同的推薦方式，因此業界許多推薦系統都會混合不同的方法，如：結合內容過濾與協同過濾、結合機器學習演算法來建立推薦系統，以增進推薦的效率。</li>
</ul>
<hr>
<h2 id="推薦系統的限制與缺點"><a href="#推薦系統的限制與缺點" class="headerlink" title="推薦系統的限制與缺點"></a>推薦系統的限制與缺點</h2><h3 id="冷啟動-Cold-Start"><a href="#冷啟動-Cold-Start" class="headerlink" title="冷啟動(Cold Start)"></a>冷啟動(Cold Start)</h3><p>碰到新用戶、新商品的情況下，沒有(被)使用或(被)瀏覽的商品，在某些推薦系統上將會發生無法推薦的窘境，我們該怎麼推薦商品？<br>解法：先以其他 Item-Based 的方式，透過新商品的屬性、新用戶的特徵來推薦給用戶，累積一定的使用資料後，再慢慢放入協同過濾所推薦的內容。</p>
<ul>
<li>冷門商品在協同過濾系統下，都不會成為推薦商品</li>
<li><strong>資料量不足以致於推薦系統效果不佳、無法使用</strong></li>
</ul>
<h3 id="探索問題-Exploit-amp-Explore-EE"><a href="#探索問題-Exploit-amp-Explore-EE" class="headerlink" title="探索問題(Exploit &amp; Explore, EE)"></a>探索問題(Exploit &amp; Explore, EE)</h3><p>Exploit 是指使用已知用戶偏好來做分析； Explore 是指探索用戶未知的興趣或者偏好。<br>解法：部分使用模型預測、熱門、隨機等方法；而如何挑選，將透過商業角度或者AB test的方式進行。</p>
<h3 id="資料稀疏-Data-Sparsity"><a href="#資料稀疏-Data-Sparsity" class="headerlink" title="資料稀疏(Data Sparsity)"></a>資料稀疏(Data Sparsity)</h3><p>某電商平台銷售同類型、過多相似的商品(資訊量過多)時，可能造成資料稀疏(Data Sparsity)的問題，即當用戶無法瀏覽大部分商品時，將會造成蒐集資料上的稀疏。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本篇文章大致講解推薦系統的基本概念，並附上 Python Code 的範例供參考 ( 數據為隨機值，運算結果可能會怪怪的 )；推薦系統的概念大致相同，應著重於如何將該系統、演算法應用於不同情境下，並解決當下的問題。</p>
<ul>
<li>一般應用：推薦系統是根據用戶相似度、商品相似度排序來進行推薦。</li>
<li>實務應用：需依照想達成的目的、解決的問題來進行調整，如：透過推薦系統加深用戶付費深度等，不一定會只考慮相似度進行；同時，後續若要進行部署也是一大挑戰，需要考量到推薦系統的運算時間、資料的標準化、是否需要即時推薦等問題，以及系統的穩定性和成效追蹤，需要有完整的數據監控系統和 AB test 方法來進行。</li>
</ul>
<p><br /><br />作者：Ian Chang <br />網址： <a href="https://yuyaochang.github.io/2022/11/03/Recommendation_System_%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%B4%B9_Python/">https://yuyaochang.github.io/2022/11/03/Recommendation_System_推薦系統概念介紹_Python&#x2F;</a> <br />版權聲明：Blog中所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/tw/">CC BY-NC-SA 3.0 TW</a> 許可協議，若要轉載請註明出處</p>
]]></content>
      <categories>
        <category>推薦系統</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Recommendation System</tag>
      </tags>
  </entry>
  <entry>
    <title>如何透過Hexo與Github架設Blog網站</title>
    <url>/2022/09/04/%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8EHexo%E8%88%87Github%E6%9E%B6%E8%A8%ADBlog%E7%B6%B2%E7%AB%99/</url>
    <content><![CDATA[<p>趁著剛架好網站，印象深刻的時候把這篇寫一寫 XD</p>
<p>當我想要架設這個Blog的時候，<br>比較過許多Blog網站，<br>例如：痞客邦、Blogger、WordPress、Medium等攥寫Blog的網站，<br>其中WordPress太過商業化，<br>想要有<del>炫炮</del>好看的頁面、功能外掛都需要付費…；<br>原本想要使用Medium(介面乾淨、整齊是主因)，<br>但因不支援Markdown、沒有掌握權等原因作罷。</p>
<p>為什麼最後選擇透過Hexo與Github架設Blog網站，<span id="more"></span><br>最主要原因當然是<strong>免費</strong>，<br>並且在免費的情況下，能夠做到：<br><em><strong>內容樣式自訂</strong></em>、<em><strong>方便管理</strong></em>、<em><strong>Markdown格式</strong></em>…等</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="建立Github帳號"><a href="#建立Github帳號" class="headerlink" title="建立Github帳號"></a>建立Github帳號</h3><p>這個網站主要是透過將Hexo的框架Deploy到Github Page下，<br>因此需要先建立一個屬於自己的<a href="https://github.com/">Github帳號</a>，<br>(Github是code版本控制工具，許多專案、教學都會存放於此)<br>並且建立一個專門給這個網站Deploy使用的Repository。</p>
<h3 id="建立Repository"><a href="#建立Repository" class="headerlink" title="建立Repository"></a>建立Repository</h3><p>帳號註冊完成後，需要先建立一個Repository。<br>這裡要注意的是：輸入的Repository名稱一定要是<code>&lt;user_name&gt;.github.io</code>，<br>並且要選擇公開(Public)。<br><img src="/images/hexo_github/create_repo.jpg" width="50%"><br>創建完Repository後，使用git clone把Repository下到本地端。<br>(看個人習慣使用<a href="https://git-scm.com/downloads">指令</a>或<a href="https://desktop.github.com/">Github Desktop</a>)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$git</span> <span class="string">clone</span> <span class="string">&lt;repo_url.git&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="https://hexo.io/zh-tw/">Hexo</a>是一個Blog框架，<br>它能夠在使用者不會寫js、css、html等語言的情況下，<br>快速建立一個靜態檔案Blog，<br>同時，具有許多套件能夠提供給使用者彈性調整網頁功能，<br>並且在文章中能夠支援Markdown格式。</p>
<h3 id="Hexo安裝"><a href="#Hexo安裝" class="headerlink" title="Hexo安裝"></a>Hexo安裝</h3><p>因為安裝Hexo需要使用<a href="https://github.com/nodejs-tw/nodejs-wiki-book/blob/master/zh-tw/node_npm.rst">npm(node package manager)</a>，<br>因此安裝前，首先需要先安裝<a href="https://nodejs.org/zh-tw/download/">Node.js</a>，<br>安裝完成後，打開Terminal輸入：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$cd</span> <span class="string">&lt;想要安裝的路徑&gt;</span></span><br><span class="line"><span class="string">$npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"><span class="string">$hexo</span> <span class="string">init</span> <span class="string">&lt;要創建的資料夾名稱&gt;</span></span><br></pre></td></tr></table></figure>
<p>完成後將會看到創好的資料夾以及內含的Hexo基本配置檔案，<br>注意：接下來需要將創好的資料夾中的所有檔案copy到clone下來的資料夾中(原資料夾就可以刪了)，<br>(如果熟悉操作也可直接安裝在clone下來的資料夾)<br>並在Terminal輸入：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$cd</span> <span class="string">&lt;clone下來的資料夾路徑&gt;</span></span><br><span class="line"><span class="string">$npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure>
<p>這樣就可以完成Hexo安裝。</p>
<h3 id="Hexo資料夾架構"><a href="#Hexo資料夾架構" class="headerlink" title="Hexo資料夾架構"></a>Hexo資料夾架構</h3><p>完成Hexo安裝後，可以看到Hexo資料夾架構大概長這樣。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">_config.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">package.json</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">package-lock.json</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">themes</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">source</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">_posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">scaffolds</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">page.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">post.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">draft.md</span></span><br></pre></td></tr></table></figure>
<p><strong>node_modules&#x2F;</strong><br><code>node_modules/</code>這個資料夾底下為專案所需要的Package。<br>(剛才透過npm install安裝的東西)<br><strong>scaffolds&#x2F;</strong><br><code>scaffolds/</code>這個資料夾主要存放預設模板，<br>當使用<code>$hexo new &lt;type&gt; &lt;name&gt;</code>來創建一個新頁面或貼文時，<br>Hexo將會使用這些模板建立檔案。<br><strong>source&#x2F;</strong><br><code>source/</code>這個資料夾主要存放網站中所有的資料，<br>除了存放文章的資料夾<code>_posts/</code>以外(存放文章的資料夾)，<br>前面帶有底線的資料夾都會被Hexo忽略掉，<br>而存在資料夾中的文章(Markdown、HTML等靜態檔案)會被放到<code>public/</code>資料夾，<br>其他檔案則會被複製過去。<br><strong>themes&#x2F;</strong><br><code>themes/</code>這個資料夾是用來存放網站佈景主題的，<br><a href="https://hexo.io/themes/">Hexo官網</a>上有許多不同的主題供大家下載，<br>下載後把整個主題資料夾放到<code>themes/</code>裡面，<br>再到<code>_config.yml</code>去改設定就可以了。<br><strong>_config.yml</strong><br><code>_config.yml</code>是最重要的設定檔，<br>在這個檔案中可以針對網站的呈現方式做設定。<br><strong>package.json</strong><br><code>package.json</code>記錄目前有安裝的套件及其版本。</p>
<h3 id="根目錄-config-yml設定重點介紹"><a href="#根目錄-config-yml設定重點介紹" class="headerlink" title="根目錄_config.yml設定重點介紹"></a>根目錄_config.yml設定重點介紹</h3><p>大致說明一下根目錄<code>_config.yml</code>設定，<br>比較會用到的設定以及要注意的地方。</p>
<h4 id="全站設定"><a href="#全站設定" class="headerlink" title="全站設定"></a>全站設定</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment"># Blog名稱</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment"># Blog副標題</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment"># Blog基本描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment"># 關鍵字</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment"># 作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="comment"># 網站語言 e.g. zh-TW</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment"># 網站時區 e.g. &#x27;Asia/Taipei&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="網站url設定"><a href="#網站url設定" class="headerlink" title="網站url設定"></a>網站url設定</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="comment"># 網站網址</span></span><br><span class="line"><span class="attr">root:</span> <span class="comment"># 網站根目錄</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="comment"># 文章永久連結的格式</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<p>注意：網站網址，必須使用 <code>http://</code> 或 <code>https://</code> 開頭。</p>
<h4 id="存放檔案的資料夾設定"><a href="#存放檔案的資料夾設定" class="headerlink" title="存放檔案的資料夾設定"></a>存放檔案的資料夾設定</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure>
<h4 id="文章寫作設定"><a href="#文章寫作設定" class="headerlink" title="文章寫作設定"></a>文章寫作設定</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span> <span class="comment"># 預設佈局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span> <span class="comment"># 將檔案名稱換成: 1小寫 或 2大寫</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span> <span class="comment"># 是否顯示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span> <span class="comment"># 啟動Asset資料夾</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span> <span class="comment"># 把連結改為與根目錄的&quot;相對&quot;位址</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span> <span class="comment"># 是否顯示未來的文章</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="首頁設定"><a href="#首頁設定" class="headerlink" title="首頁設定"></a>首頁設定</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span> <span class="comment"># 首頁顯示文章數</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span> <span class="comment"># 文章排序(預設依日期越新越上面)</span></span><br></pre></td></tr></table></figure>
<p>這部分基本上可以安裝<code>hexo-generator-index2</code>套件取代，<br>後續提到會再介紹。</p>
<h4 id="分頁設定"><a href="#分頁設定" class="headerlink" title="分頁設定"></a>分頁設定</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br></pre></td></tr></table></figure>
<p><code>per_page</code>可以設定一頁顯示的文章量，<br>若設定0表示關閉分頁功能。</p>
<h4 id="包含-x2F-不包含"><a href="#包含-x2F-不包含" class="headerlink" title="包含 &#x2F; 不包含"></a>包含 &#x2F; 不包含</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span> <span class="comment"># Hexo預設忽略的隱藏檔、資料夾，若將其列在此Hexo將會使用</span></span><br><span class="line"><span class="attr">exclude:</span> <span class="comment"># 列在此的檔案、資料夾Hexo將會忽略</span></span><br><span class="line"><span class="attr">ignore:</span></span><br></pre></td></tr></table></figure>
<p>在此需注意二點：</p>
<ol>
<li>列在這些項目下的檔案、資料夾需要加雙引號或單引號，如：<code>&quot;&lt;檔案名稱&gt;&quot;</code>或<code>&#39;&lt;檔案名稱&gt;&#39;</code>。</li>
<li>若要忽略<code>themes/</code>資料夾中的內容，需加<code>_</code>在前面，如：<code>_檔案名稱</code>。</li>
</ol>
<h4 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">&lt;Blog主題&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://hexo.io/themes/">Hexo官方網站</a>有許多主題可供下載，<br>只要將主題下載下來後，<br>放入<code>themes/</code>資料夾中(通常會存成<code>themes/主題名稱/主題檔案</code>)，<br>並將此處Blog主題設定為所下載的主題名稱即可。</p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;user_name&gt;/&lt;repo_name&gt;.git</span></span><br><span class="line">  <span class="attr">branch:</span>  <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>因為是使用Github來進行Deploy，<br>需要先安裝<code>hexo-deployer-git</code><a href="https://hexo.io/zh-tw/docs/one-command-deployment.html">套件</a>，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>
<p>如果沒安裝將會出現ERROR Deployer not found:git。</p>
<h3 id="將Hexo部署到Github-Page"><a href="#將Hexo部署到Github-Page" class="headerlink" title="將Hexo部署到Github Page"></a>將Hexo部署到Github Page</h3><p>將<code>_config.yml</code>設定檔調整完成後，<br>即可開始將Hexo部署到Github Page，<br>一樣先打開Terminal，並切換到clone下來的資料夾，並輸入：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">$cd</span> <span class="string">&lt;clone下來的資料夾路徑&gt;</span></span><br><span class="line"><span class="string">$hexo</span> <span class="string">clean</span> <span class="comment"># 清除快取檔案db.json、已產生的靜態檔案public</span></span><br><span class="line"><span class="string">$hexo</span> <span class="string">generate</span> <span class="comment"># 產生靜態檔案</span></span><br><span class="line"><span class="string">$hexo</span> <span class="string">server</span> <span class="comment"># 啟動伺服器，預設為http://localhost:4000/</span></span><br><span class="line"><span class="string">$hexo</span> <span class="string">deploy</span> <span class="comment"># 部署網站</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>$hexo server</code>不一定需要使用，<br>它主要是用來在本地端導覽網站內容(像是測試使用)，<br>使用時，如果預設的port埠已使用，<br>可以透過<code>$hexo server -p &lt;port埠&gt;</code>使用另一個port埠來啟動伺服器；<br>當使用<code>$hexo deploy</code>完成Deploy後，<br>等待一下再到你的Blog頁面<code>https://&lt;user_name&gt;.github.io/</code>，<br>就可以看到你的Blog網站了。</p>
<p>注意：Deploy後，可能會有一種情況是多了一個<code>branch</code>，<br>(這取決於你怎麼設定<code># Deployment</code>的部分)<br>如果發生Deploy後等很久網站沒有更新的狀況，<br>需檢查Github Page設定的地方，<br>目前所設定的<code>branch</code>是否為Deploy的<code>branch</code>。<br><img src="/images/hexo_github/github_page.jpg" width="50%"><br>另外，經過Deploy後的Hexo檔案是轉換過的，並非原始檔，<br>因此，建議如有需要可透過<code>branch</code>的方式能夠將原始檔保存於Github中進行版控。</p>
<p>完成以上步驟後，基本的Blog網站就設定好了~</p>
<p>延伸閱讀：<br><a href="https://yuyaochang.github.io/2022/09/18/NexT%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A%E3%80%81%E5%AF%A6%E9%9A%9B%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AHexo%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%A5%97%E4%BB%B6/#more">NexT主題設定、實際使用Hexo及Hexo其他常用套件</a></p>
<p><br /><br />作者：Ian Chang <br />網址： <a href="https://yuyaochang.github.io/2022/09/04/%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8EHexo%E8%88%87Github%E6%9E%B6%E8%A8%ADBlog%E7%B6%B2%E7%AB%99/">https://yuyaochang.github.io/2022/09/04/如何透過Hexo與Github架設Blog網站/</a> <br />版權聲明：Blog中所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/tw/">CC BY-NC-SA 3.0 TW</a> 許可協議，若要轉載請註明出處</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>投資初心者系列_交易模式</title>
    <url>/2022/10/15/%E6%8A%95%E8%B3%87%E5%88%9D%E5%BF%83%E8%80%85%E7%B3%BB%E5%88%97_%E4%BA%A4%E6%98%93%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>近年來投資市場越來越熱絡，<br>或許是因為多數人的理財觀念有所提升，知道把錢存在銀行會因為通貨膨脹而越變越薄；<br>又或是從過去的經驗來看把錢投入股市，長期而言，<br>股市將會不斷的上漲，即便跌得再深都有漲回來的一天。<br>(會不會每次都漲回來我自己持保留態度，後續有機會再探討這個議題)</p>
<p>本系列希望講述一些投資相關基本知識以及我個人認為投資中最重要的事，<br>第一篇就先以交易模式作為主要介紹內容。</p>
<h3 id="學投資的第一步應該要做什麼"><a href="#學投資的第一步應該要做什麼" class="headerlink" title="學投資的第一步應該要做什麼?"></a>學投資的第一步應該要做什麼?</h3><p>看到這個標題很多人會直覺回答：<strong>當然是學怎麼賺錢囉~</strong><span id="more"></span><br>我認為這句話對也不對，<br>許多人學投資的第一步是去了解：基本面分析、技術面分析、看投顧老師節目等，<br>試圖了解如何挑選到會上漲的標的，但往往不會考慮到背後的風險，<br>在投資的過程中，永遠要記住<strong>期望的報酬越高，風險將會越大</strong>；<br>而賺錢是希望透過投資達到的最終目的，<br>但想要達到這個目的會需要滿足很多種條件，<br>不只是單靠挑選到會上漲的標的就好，<br>還需要透過資金、風險管理等方式，做一些看錯方向時的停損、下跌保護等操作。<br><del>當然如果你非常厲害勝率100%永遠不會看錯方向…另當別論</del></p>
<h3 id="交易模式"><a href="#交易模式" class="headerlink" title="交易模式"></a>交易模式</h3><p>投資最重要的事，其中之一就是<strong>交易模式</strong>。</p>
<p>為什麼要了解交易模式？</p>
<p>市場是由許多不同的人所組成的，<br>每個人所制定的交易邏輯、進出場策略以及對未來趨勢的看法都不一樣，<br><code>tips:市場上要有不同的操作、看法才會促成市場成交(流動性)</code><br>因此，制訂一套適合自已、擅長操作的交易模式是非常重要的。</p>
<p>要了解自己的個性、風險承受度適合哪種交易模式，<br>首先，要先了解交易模式有哪些，<br>交易模式主要可以分成左側交易與右側交易。</p>
<h4 id="左側交易-逆勢交易"><a href="#左側交易-逆勢交易" class="headerlink" title="左側交易(逆勢交易)"></a>左側交易(逆勢交易)</h4><p>左側交易(逆勢交易)的概念，<br>主要是<strong>在下跌時分批買入，在上漲時分批賣出</strong>，<br>這種交易模式又可稱為<strong>價值投資</strong>，<br>當標的下跌到合理價格範圍時，分批佈局；<br>左側交易比較適合具有長期投資(或搶反彈)、資金龐大、有耐心、心理素質強等因素的投資者，<br>這種交易模式較違反人性，<br>當標的下跌越多時，需要買入的部位越多，<br>因此挑選對標的、做好資金管理就是一件十分重要的事。</p>
<img src="/images/Investment/左側交易.jpg" width="50%">

<p>左側交易最害怕的是<strong>下跌時分批買入，最後股價沒有回升、被套牢</strong>，<br>因此，在挑選標的的部分：<br>標的要符合長期上行趨勢、體質強健等條件，<br>如果標的體質不夠強健，遇到熊市時，<br>無法保證標的是否能撐過熊市時期(如：股票下市、營收持續惡化等)；<br>如果長期不為上行趨勢，熬過下跌後，<br>後續上漲的機率可能相較於長期上行趨勢的標的來的低。</p>
<p>而在資金管理的部分，<br>左側交易需要控制下跌時分批買入以及上漲時分批賣出的速度，<br>否則容易遇到在長期下跌的過程中，買入速度太快，導致平均持倉成本過高(套牢在高點)，<br>並且當標的價格較低時，已無資金可以進場壓低平均持倉成本；<br>又或者在上漲的過程中，賣出速度太快，導致錯過後續長期多頭的中後段漲幅(魚尾留給別人賺)。</p>
<p>從資金管理的邏輯上，也將延伸出另一個問題，<br>左側交易需要了解目前標的價格是否在一個合理的價位，<br>或者說需要了解市場當下對該標的折溢價狀況是否合理，<br>這會需要有很多基本面(標的、總體經濟等)的相關知識才能夠進行判斷。</p>
<p>優點：</p>
<ol>
<li>買在相對低點，長期持有勝率、獲利空間較大。</li>
<li>較不會有滑價問題。</li>
<li><del>標的價格遠離成本價後，可以安心睡覺。</del></li>
</ol>
<p>缺點：</p>
<ol>
<li>等待反彈並獲利所需要的時間很長、時間成本高。</li>
<li>投資者需要有強大的心理素質，在下跌的過程中，堅持自己的交易決策。</li>
</ol>
<h4 id="右側交易-順勢交易"><a href="#右側交易-順勢交易" class="headerlink" title="右側交易(順勢交易)"></a>右側交易(順勢交易)</h4><p>右側交易(順勢交易)的概念，<br>主要是<strong>在上漲時分批買入，在下跌時分批賣出</strong>，<br>這種交易模式又可稱為<strong>動能交易</strong>，<br>當標的出現底部型態且已出現上漲趨勢時，分批買入，<br>待標的漲到頂部且已開始下跌時，分批賣出，<br>即不預測未來漲跌，只跟著市場趨勢順勢做交易；<br>這種交易模式較適合具有遵守交易紀律、做短線、做波段等因素的投資者。</p>
<img src="/images/Investment/右側交易.jpg" width="50%">


<p>這種交易模式所交易的標的需要有一定的波動性，<br>不能夠選擇長期盤整或波動性低的標的，<br>主要原因在於此交易模式都是等到價格有明確突破、跌破時，才會進場交易，<br>進場時，標的價格已漲過一段，趨勢很容易出現反轉，<br>可能造成才剛進場沒多久馬上就要減碼甚至是出場，<br>因此其勝率通常較左側交易低；<br>同時，在右側交易的交易模式中，投資者需要有果斷的交易紀律，<br>無論是在加碼、減碼、停損、停利等交易策略上，<br>都需要嚴格進行遵守，並遵循汰弱留強的標的篩選機制。</p>
<p>優點：</p>
<ol>
<li>價格有明確突破、跌破時進行交易，時間成本較少。</li>
<li>若嚴格遵守交易紀律，風險較低。</li>
<li>持倉時間較短，資金週轉率高。</li>
</ol>
<p>缺點：</p>
<ol>
<li>獲利空間僅有中間的波段部分，且進場後容易出現反轉</li>
<li>時常發生反轉(上沖下洗)可能會造成不斷停損時資金的耗損</li>
</ol>
<h3 id="交易一致性"><a href="#交易一致性" class="headerlink" title="交易一致性"></a>交易一致性</h3><p>在交易的過程中，交易一致性是非常重要的，<br>舉個例子來說，如果你做的是右側交易，<br>你必需遵守你所設定的交易紀律(策略)，可能包含：</p>
<ol>
<li>進場條件：突破價格進場做多、跌破價格進場做空等</li>
<li>出場條件：觸及停利價格則停利出場、觸及停損價格則停損出場等</li>
</ol>
<p>嚴格遵守交易紀律說起來很容易，<br>但常常在投資者的心理上實踐並不容易，<br>設想今天進場的標的是台積電(2330.TW)，<br>當價格已經跌到你的交易策略中預計應該停損的位置，<br>但市場、媒體、投顧分析師等都告訴你現在是低點應該要進場，<br>並且對它未來的產業展望、企業營收等都具有正面的評價；<br>在這樣的情境下，<br>你能否堅持自己的交易紀律，果斷地去執行停損的動作，<br>如果你已經可以做到，那你在投資的道路上會順利許多，<br>如果你目前還無法做到，那這是你需要學習、練習的一部分。</p>
<p>投資者保持自己的交易一致性是很重要的，遵循自己所設定好的交易紀律，<br><strong>進場前需預先想好進場的條件、價位，進場後需預先想好出場的條件、方式</strong>，<br>不被外在的因素(新聞、投顧分析師等)影響自己的交易策略，<br>當進場的理由消失、停損點到達時，就是要出場的時候，<br>這些都是作為投資者應該要有的交易紀律。</p>
<p><code>tips:投資者必需嚴格遵守交易紀律，任何事情都不能影響這些規則</code></p>
<p><br /><br />作者：Ian Chang <br />網址： <a href="https://yuyaochang.github.io/2022/10/15/%E6%8A%95%E8%B3%87%E5%88%9D%E5%BF%83%E8%80%85%E7%B3%BB%E5%88%97_%E4%BA%A4%E6%98%93%E6%A8%A1%E5%BC%8F/">https://yuyaochang.github.io/2022/10/15/投資初心者系列_交易模式&#x2F;</a> <br />版權聲明：Blog中所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/tw/">CC BY-NC-SA 3.0 TW</a> 許可協議，若要轉載請註明出處</p>
]]></content>
      <categories>
        <category>Investment</category>
      </categories>
      <tags>
        <tag>Investment</tag>
        <tag>投資初心者系列</tag>
      </tags>
  </entry>
</search>
